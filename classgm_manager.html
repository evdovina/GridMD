<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GridMD: gmManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GridMD
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgm_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gmManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main interface class to access workflow functions.  
 <a href="classgm_manager.html#details">More...</a></p>

<p><code>#include &lt;gridmd.h&gt;</code></p>
<div class="dynheader">
Collaboration diagram for gmManager:</div>
<div class="dyncontent">
<div class="center"><img src="classgm_manager__coll__graph.png" border="0" usemap="#gm_manager_coll__map" alt="Collaboration graph"/></div>
<map name="gm_manager_coll__map" id="gm_manager_coll__map">
<area shape="rect" id="node5" href="classgm_scheduler.html" title="Scheduler managing different resources. " alt="" coords="585,123,683,149"/>
<area shape="rect" id="node2" href="classgm_manager_callback.html" title="Call&#45;back events, sent by gmManager. Set of events may be extended. " alt="" coords="34,44,171,71"/>
<area shape="rect" id="node3" href="classrefmap.html" title="refmap\&lt; string, gmLinkData \&gt;" alt="" coords="5,95,200,121"/>
<area shape="rect" id="node4" href="classmngptr.html" title="mngptr\&lt; gmNodeAction \&gt;" alt="" coords="17,145,188,172"/>
<area shape="rect" id="node6" href="classrefvector.html" title="refvector\&lt; gmShell \&gt;" alt="" coords="318,49,463,76"/>
<area shape="rect" id="node7" href="classrefvector.html" title="refvector\&lt; gmResource \&gt;" alt="" coords="305,100,476,127"/>
<area shape="rect" id="node8" href="structgm_node_prop.html" title="Properties of the node affected by the user configurable settings. " alt="" coords="55,196,150,223"/>
<area shape="rect" id="node9" href="classgm_mutex.html" title="mutex is used to lock access to file&#45;stored information, like &#39;restor file&#39; and &#39;*.dot graph&#39;. " alt="" coords="65,285,140,312"/>
<area shape="rect" id="node10" href="classint__pack.html" title="class for packing integers " alt="" coords="68,336,137,363"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac99239279efc5792b3cd934b50cda26e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ac99239279efc5792b3cd934b50cda26e">gmManager</a> (int mode=gmMODE_LOCAL, <a class="el" href="classgm_mutex.html">gmMutex</a> *<a class="el" href="classgm_manager.html#a096cbc51cb8904649ce80ce7c21171e5">mutex</a>=&amp;gmMutex::voidMutex, <a class="el" href="classgm_manager_callback.html">gmManagerCallback</a> *call_back=&amp;gmManagerCallback::voidCallBack)</td></tr>
<tr class="memdesc:ac99239279efc5792b3cd934b50cda26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ac99239279efc5792b3cd934b50cda26e">More...</a><br /></td></tr>
<tr class="separator:ac99239279efc5792b3cd934b50cda26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e30f427b3c6aa94b101208c95ce4e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e30f427b3c6aa94b101208c95ce4e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a16e30f427b3c6aa94b101208c95ce4e5">~gmManager</a> ()</td></tr>
<tr class="memdesc:a16e30f427b3c6aa94b101208c95ce4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a16e30f427b3c6aa94b101208c95ce4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9280f4f429adcb0cdb1c0c3ab42c12ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a9280f4f429adcb0cdb1c0c3ab42c12ca">init</a> (int &amp;argc, charDoublePtr &amp;argv, const string &amp;name_=&quot;gmexp&quot;)</td></tr>
<tr class="memdesc:a9280f4f429adcb0cdb1c0c3ab42c12ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical experiment initialization.  <a href="#a9280f4f429adcb0cdb1c0c3ab42c12ca">More...</a><br /></td></tr>
<tr class="separator:a9280f4f429adcb0cdb1c0c3ab42c12ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614259fb328ff65f9395344ccceda3fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a614259fb328ff65f9395344ccceda3fd">init</a> (const string &amp;name_, bool restart=false, bool recalc_locals=false, const string &amp;restart_file_=&quot;&quot;)</td></tr>
<tr class="memdesc:a614259fb328ff65f9395344ccceda3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical experiment initialization (local manager mode only).  <a href="#a614259fb328ff65f9395344ccceda3fd">More...</a><br /></td></tr>
<tr class="separator:a614259fb328ff65f9395344ccceda3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0d826c85e6790d68f3734978d7512f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa0d826c85e6790d68f3734978d7512f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aaa0d826c85e6790d68f3734978d7512f">gmManager</a> (const string &amp;name_, bool restart=false, bool recalc_locals=false, const string &amp;restart_file_=&quot;&quot;)</td></tr>
<tr class="memdesc:aaa0d826c85e6790d68f3734978d7512f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor immediately initializing with <a class="el" href="classgm_manager.html#a9280f4f429adcb0cdb1c0c3ab42c12ca">init()</a> <br /></td></tr>
<tr class="separator:aaa0d826c85e6790d68f3734978d7512f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae183940ff0cbed034cc1003442d2d4b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ae183940ff0cbed034cc1003442d2d4b0">add_resource</a> (const <a class="el" href="structgm_resource_descr.html">gmResourceDescr</a> &amp;rdescr, const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:ae183940ff0cbed034cc1003442d2d4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the compute resource into the remote resource description list Default resource <em>name</em> is the same as hostname in the description.  <a href="#ae183940ff0cbed034cc1003442d2d4b0">More...</a><br /></td></tr>
<tr class="separator:ae183940ff0cbed034cc1003442d2d4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501caf713de8f4c103c611c616eb8baf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a501caf713de8f4c103c611c616eb8baf">load_resources</a> (const char *filename)</td></tr>
<tr class="memdesc:a501caf713de8f4c103c611c616eb8baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds compute resources found in the given XML file to the list of resources.  <a href="#a501caf713de8f4c103c611c616eb8baf">More...</a><br /></td></tr>
<tr class="separator:a501caf713de8f4c103c611c616eb8baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a214ec07a5873474232350334772056"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a0a214ec07a5873474232350334772056">save_resources</a> (const char *filename)</td></tr>
<tr class="memdesc:a0a214ec07a5873474232350334772056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves current list of compute resources into XML file.  <a href="#a0a214ec07a5873474232350334772056">More...</a><br /></td></tr>
<tr class="separator:a0a214ec07a5873474232350334772056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac327a40c5e756ea35f922169403557f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ac327a40c5e756ea35f922169403557f2">write_graph</a> ()</td></tr>
<tr class="memdesc:ac327a40c5e756ea35f922169403557f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the graph to corresponding file(s) (graphwiz, xml, etc).  <a href="#ac327a40c5e756ea35f922169403557f2">More...</a><br /></td></tr>
<tr class="separator:ac327a40c5e756ea35f922169403557f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007b92bdad63f1944279c26df7adf35f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a007b92bdad63f1944279c26df7adf35f">set_link_files</a> (int file_flags=0)</td></tr>
<tr class="memdesc:a007b92bdad63f1944279c26df7adf35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit flags for temporary files handling modes (see gmTMP_FILES).  <a href="#a007b92bdad63f1944279c26df7adf35f">More...</a><br /></td></tr>
<tr class="separator:a007b92bdad63f1944279c26df7adf35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba04aa8da009ef42eaf5aee43bb343"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a01ba04aa8da009ef42eaf5aee43bb343">set_graphviz_flags</a> (int flags=gmGV_ALL)</td></tr>
<tr class="memdesc:a01ba04aa8da009ef42eaf5aee43bb343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets graphviz output flags (combination of gmGV_FIELDS).  <a href="#a01ba04aa8da009ef42eaf5aee43bb343">More...</a><br /></td></tr>
<tr class="separator:a01ba04aa8da009ef42eaf5aee43bb343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec152dc25f69890328cd26f690409c51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aec152dc25f69890328cd26f690409c51">set_graphviz_output</a> (int mode=2)</td></tr>
<tr class="memdesc:aec152dc25f69890328cd26f690409c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches automatic graphviz (dot) output modes: 0 = off, 1 = auto update in execute, 2 = auto update by each graph change <br />
 Operation modes: local, construct<br />
.  <a href="#aec152dc25f69890328cd26f690409c51">More...</a><br /></td></tr>
<tr class="separator:aec152dc25f69890328cd26f690409c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ecd0ebe94273f9d5052e68c0be2b62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78ecd0ebe94273f9d5052e68c0be2b62"></a>
gmGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a78ecd0ebe94273f9d5052e68c0be2b62">get_graph</a> ()</td></tr>
<tr class="memdesc:a78ecd0ebe94273f9d5052e68c0be2b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the graph object (for use in skeleton extensions only). <br /></td></tr>
<tr class="separator:a78ecd0ebe94273f9d5052e68c0be2b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bc6c463b3e583b352737b527c208d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a12bc6c463b3e583b352737b527c208d8">set_execution</a> (int flags=gmEXE_LOCAL)</td></tr>
<tr class="memdesc:a12bc6c463b3e583b352737b527c208d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set execution mode (one of gmEXE_MODES).  <a href="#a12bc6c463b3e583b352737b527c208d8">More...</a><br /></td></tr>
<tr class="separator:a12bc6c463b3e583b352737b527c208d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64858b00f85761f680e10aece3f3de70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64858b00f85761f680e10aece3f3de70"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a64858b00f85761f680e10aece3f3de70">get_mode</a> () const </td></tr>
<tr class="memdesc:a64858b00f85761f680e10aece3f3de70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current operation mode (see gmMODES). <br /></td></tr>
<tr class="separator:a64858b00f85761f680e10aece3f3de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3abb879f63b695cdac6036e6e2050bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#af3abb879f63b695cdac6036e6e2050bc">get_recursion</a> () const </td></tr>
<tr class="memdesc:af3abb879f63b695cdac6036e6e2050bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current gridmd_main recurison level between 0 and <a class="el" href="gridmd_8h.html#a450e276931e2754b3073ff99aa2e64c6">MAX_RECURSION</a>.  <a href="#af3abb879f63b695cdac6036e6e2050bc">More...</a><br /></td></tr>
<tr class="separator:af3abb879f63b695cdac6036e6e2050bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e62a1de7ce23910936c5286cd405aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa">begin_distributed</a> ()</td></tr>
<tr class="memdesc:a72e62a1de7ce23910936c5286cd405aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Here begins the distributed portion of <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main</a>(...) that ends with <a class="el" href="classgm_manager.html#a2514f6c10286b47c248eccd802e8ced6">end_distributed()</a>.  <a href="#a72e62a1de7ce23910936c5286cd405aa">More...</a><br /></td></tr>
<tr class="separator:a72e62a1de7ce23910936c5286cd405aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2514f6c10286b47c248eccd802e8ced6"><td class="memTemplParams" colspan="2">template&lt;class link_type &gt; </td></tr>
<tr class="memitem:a2514f6c10286b47c248eccd802e8ced6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a2514f6c10286b47c248eccd802e8ced6">end_distributed</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>=&quot;finish&quot;, gmSelector input=gmNODE_NOOUTPUTS, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1)</td></tr>
<tr class="memdesc:a2514f6c10286b47c248eccd802e8ced6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Here ends the distributed part of the application that begins with <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa">begin_distributed()</a>.  <a href="#a2514f6c10286b47c248eccd802e8ced6">More...</a><br /></td></tr>
<tr class="separator:a2514f6c10286b47c248eccd802e8ced6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edaac7ae9a88f06d694cffbedffe53b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5edaac7ae9a88f06d694cffbedffe53b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a5edaac7ae9a88f06d694cffbedffe53b">end_distributed</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>=&quot;finish&quot;, gmSelector input=gmNODE_PREV)</td></tr>
<tr class="memdesc:a5edaac7ae9a88f06d694cffbedffe53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above for hard links. <br /></td></tr>
<tr class="separator:a5edaac7ae9a88f06d694cffbedffe53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92d0356594f86615e87fea21df50de5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae92d0356594f86615e87fea21df50de5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ae92d0356594f86615e87fea21df50de5">mark_distributed</a> ()</td></tr>
<tr class="memdesc:ae92d0356594f86615e87fea21df50de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa">begin_distributed()</a> <br /></td></tr>
<tr class="separator:ae92d0356594f86615e87fea21df50de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a18809cb1eb99fa2f63e2b36b903c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ad1a18809cb1eb99fa2f63e2b36b903c6">execute</a> (bool wait=true, int cleanup=-1, int max_schedules=-1)</td></tr>
<tr class="memdesc:ad1a18809cb1eb99fa2f63e2b36b903c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes workflow graph from its current state.  <a href="#ad1a18809cb1eb99fa2f63e2b36b903c6">More...</a><br /></td></tr>
<tr class="separator:ad1a18809cb1eb99fa2f63e2b36b903c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3f9a543d08afe6f989b81ad8b49000"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a5b3f9a543d08afe6f989b81ad8b49000">execute_iteration</a> ()</td></tr>
<tr class="memdesc:a5b3f9a543d08afe6f989b81ad8b49000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs one sheduling iteration of workflow graph from its current state.  <a href="#a5b3f9a543d08afe6f989b81ad8b49000">More...</a><br /></td></tr>
<tr class="separator:a5b3f9a543d08afe6f989b81ad8b49000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d975deb3a44c8cd1dcfe3c75195c62c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a9d975deb3a44c8cd1dcfe3c75195c62c">stop_all</a> (bool fetch_results=false, int cleanup=-1)</td></tr>
<tr class="memdesc:a9d975deb3a44c8cd1dcfe3c75195c62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops jobs for all executing nodes.  <a href="#a9d975deb3a44c8cd1dcfe3c75195c62c">More...</a><br /></td></tr>
<tr class="separator:a9d975deb3a44c8cd1dcfe3c75195c62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97b97c47ac73259f2060521d8624dde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ac97b97c47ac73259f2060521d8624dde">stop_node</a> (<a class="el" href="classgm_selector.html">gmSelector</a> nodes, bool fetch_results=false, int cleanup=-1)</td></tr>
<tr class="memdesc:ac97b97c47ac73259f2060521d8624dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops jobs for nodes matching a given selector in case they are executing.  <a href="#ac97b97c47ac73259f2060521d8624dde">More...</a><br /></td></tr>
<tr class="separator:ac97b97c47ac73259f2060521d8624dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af226f7934194a6299fa47f2730e31f1c"><td class="memTemplParams" colspan="2">template&lt;class link_type &gt; </td></tr>
<tr class="memitem:af226f7934194a6299fa47f2730e31f1c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c">mark_node</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1)</td></tr>
<tr class="memdesc:af226f7934194a6299fa47f2730e31f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph (construction mode), triggers processing of this node (worker mode).  <a href="#af226f7934194a6299fa47f2730e31f1c">More...</a><br /></td></tr>
<tr class="separator:af226f7934194a6299fa47f2730e31f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f41f1887948c71c4ed17eab59c794fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f41f1887948c71c4ed17eab59c794fa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a9f41f1887948c71c4ed17eab59c794fa">mark_node</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV)</td></tr>
<tr class="memdesc:a9f41f1887948c71c4ed17eab59c794fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above for hard links. <br /></td></tr>
<tr class="separator:a9f41f1887948c71c4ed17eab59c794fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259ad9e606b0bd489248aca49d31ab05"><td class="memTemplParams" colspan="2">template&lt;class link_type &gt; </td></tr>
<tr class="memitem:a259ad9e606b0bd489248aca49d31ab05"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a259ad9e606b0bd489248aca49d31ab05">local_node</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1)</td></tr>
<tr class="memdesc:a259ad9e606b0bd489248aca49d31ab05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a local node to the graph (construction mode), triggers processing of this node (worker mode).  <a href="#a259ad9e606b0bd489248aca49d31ab05">More...</a><br /></td></tr>
<tr class="separator:a259ad9e606b0bd489248aca49d31ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80df255dd9b26fb0d73c0e20b62fdf3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80df255dd9b26fb0d73c0e20b62fdf3a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a80df255dd9b26fb0d73c0e20b62fdf3a">local_node</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV)</td></tr>
<tr class="memdesc:a80df255dd9b26fb0d73c0e20b62fdf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above for hard links. <br /></td></tr>
<tr class="separator:a80df255dd9b26fb0d73c0e20b62fdf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40868e358be246e24156644747ba9871"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40868e358be246e24156644747ba9871"></a>
template&lt;class link_type &gt; </td></tr>
<tr class="memitem:a40868e358be246e24156644747ba9871"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a40868e358be246e24156644747ba9871">node</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1)</td></tr>
<tr class="memdesc:a40868e358be246e24156644747ba9871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c">mark_node</a>. <br /></td></tr>
<tr class="separator:a40868e358be246e24156644747ba9871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c3ec754d91adb3ee75fc6255bbea30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1c3ec754d91adb3ee75fc6255bbea30"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aa1c3ec754d91adb3ee75fc6255bbea30">node</a> (const string &amp;<a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a>, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV)</td></tr>
<tr class="memdesc:aa1c3ec754d91adb3ee75fc6255bbea30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c">mark_node</a>. <br /></td></tr>
<tr class="separator:aa1c3ec754d91adb3ee75fc6255bbea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf3121375700aee1680493f63060e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a5cf3121375700aee1680493f63060e2f">select_nodes</a> (std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;nodes, <a class="el" href="classgm_selector.html">gmSelector</a> selector, bool input=true, int def_port=-1, int closest_to=-1) const </td></tr>
<tr class="memdesc:a5cf3121375700aee1680493f63060e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects nodes/ports matching given selector into a std::pair vector {nodeid,portid}. Parameter <em>input</em> is not used currently.  <a href="#a5cf3121375700aee1680493f63060e2f">More...</a><br /></td></tr>
<tr class="separator:a5cf3121375700aee1680493f63060e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3e4819dd0e59183dd9462d4863e462"><td class="memItemLeft" align="right" valign="top">gmNodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a0a3e4819dd0e59183dd9462d4863e462">find_node</a> (const <a class="el" href="classgm_selector.html">gmSelector</a> &amp;selector)</td></tr>
<tr class="memdesc:a0a3e4819dd0e59183dd9462d4863e462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds one node mathching the selector.  <a href="#a0a3e4819dd0e59183dd9462d4863e462">More...</a><br /></td></tr>
<tr class="separator:a0a3e4819dd0e59183dd9462d4863e462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45232368ce74f636612540243396e4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ae45232368ce74f636612540243396e4e">select_edges</a> (std::vector&lt; gmEdgeID &gt; &amp;edges, <a class="el" href="classgm_selector.html">gmSelector</a> source, <a class="el" href="classgm_selector.html">gmSelector</a> dest, int srcport=-1, int destport=-1) const </td></tr>
<tr class="memdesc:ae45232368ce74f636612540243396e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects edges matching all pairs of source and destination node selectors.  <a href="#ae45232368ce74f636612540243396e4e">More...</a><br /></td></tr>
<tr class="separator:ae45232368ce74f636612540243396e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513d0b75131431de93aa8ed85af739ad"><td class="memItemLeft" align="right" valign="top">gmEdgeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a513d0b75131431de93aa8ed85af739ad">find_edge</a> (gmNodeID source, gmNodeID dest) const </td></tr>
<tr class="memdesc:a513d0b75131431de93aa8ed85af739ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds one edge by source and destination node ids.  <a href="#a513d0b75131431de93aa8ed85af739ad">More...</a><br /></td></tr>
<tr class="separator:a513d0b75131431de93aa8ed85af739ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e06718033764221b07de7277f65c84"><td class="memTemplParams" colspan="2">template&lt;class data_t &gt; </td></tr>
<tr class="memitem:a06e06718033764221b07de7277f65c84"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a06e06718033764221b07de7277f65c84">link</a> (<a class="el" href="classgm_selector.html">gmSelector</a> from, <a class="el" href="classgm_selector.html">gmSelector</a> to, int srcport=-1)</td></tr>
<tr class="memdesc:a06e06718033764221b07de7277f65c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links the nodes indicated by selectors <em>from</em> and <em>to</em> with data or hard link.  <a href="#a06e06718033764221b07de7277f65c84">More...</a><br /></td></tr>
<tr class="separator:a06e06718033764221b07de7277f65c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932e7f0624acc05d5205e198f565f785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a932e7f0624acc05d5205e198f565f785">process_cur_node</a> ()</td></tr>
<tr class="memdesc:a932e7f0624acc05d5205e198f565f785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 only in worker mode and only when current node needs to be processed.  <a href="#a932e7f0624acc05d5205e198f565f785">More...</a><br /></td></tr>
<tr class="separator:a932e7f0624acc05d5205e198f565f785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1439d8828906822d14c9b924c55942"><td class="memTemplParams" colspan="2">template&lt;class data_t &gt; </td></tr>
<tr class="memitem:aaf1439d8828906822d14c9b924c55942"><td class="memTemplItemLeft" align="right" valign="top">gmlink_traits&lt; data_t &gt;::value_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aaf1439d8828906822d14c9b924c55942">node_output</a> (int portid=0)</td></tr>
<tr class="memdesc:aaf1439d8828906822d14c9b924c55942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output associated with given data port (default is 0) for the current node.  <a href="#aaf1439d8828906822d14c9b924c55942">More...</a><br /></td></tr>
<tr class="separator:aaf1439d8828906822d14c9b924c55942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bc6eecad57c0339d593971a41342c2"><td class="memTemplParams" colspan="2">template&lt;class data_t &gt; </td></tr>
<tr class="memitem:a05bc6eecad57c0339d593971a41342c2"><td class="memTemplItemLeft" align="right" valign="top">const gmlink_traits&lt; data_t &gt;::value_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a05bc6eecad57c0339d593971a41342c2">node_input</a> (int portid=0)</td></tr>
<tr class="memdesc:a05bc6eecad57c0339d593971a41342c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get input associated with given data port (default is 0) for the current node.  <a href="#a05bc6eecad57c0339d593971a41342c2">More...</a><br /></td></tr>
<tr class="separator:a05bc6eecad57c0339d593971a41342c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3390774546f15134b595209f2402938"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3390774546f15134b595209f2402938"></a>
gmNodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ab3390774546f15134b595209f2402938">get_curnode</a> () const </td></tr>
<tr class="memdesc:ab3390774546f15134b595209f2402938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current node ID. <br /></td></tr>
<tr class="separator:ab3390774546f15134b595209f2402938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea38c179e88a0f653bce8f048270b541"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea38c179e88a0f653bce8f048270b541"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aea38c179e88a0f653bce8f048270b541">check_distrnode</a> () const </td></tr>
<tr class="memdesc:aea38c179e88a0f653bce8f048270b541"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the distr_node before advancing nodeid also checks the error status of the last graph, otherwise returns 0 <br /></td></tr>
<tr class="separator:aea38c179e88a0f653bce8f048270b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b28a77418f73e6fc5c64af40972320e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b28a77418f73e6fc5c64af40972320e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a7b28a77418f73e6fc5c64af40972320e">check_subgraph</a> (gmNodeID <a class="el" href="classgm_manager.html#a40868e358be246e24156644747ba9871">node</a>)</td></tr>
<tr class="memdesc:a7b28a77418f73e6fc5c64af40972320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that the node with given ID belongs to the subgraph being executed throws exception when the subgraph is finished <br /></td></tr>
<tr class="separator:a7b28a77418f73e6fc5c64af40972320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50185cdbd222efa66bf8dba726dc08b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ae50185cdbd222efa66bf8dba726dc08b">in_construction</a> () const </td></tr>
<tr class="memdesc:ae50185cdbd222efa66bf8dba726dc08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the manager is in construction mode and in the current distributed section of the code, FALSE otherwise.  <a href="#ae50185cdbd222efa66bf8dba726dc08b">More...</a><br /></td></tr>
<tr class="separator:ae50185cdbd222efa66bf8dba726dc08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a3504fca0e594d7f3a6cbb2a9684ef"><td class="memTemplParams" colspan="2">template&lt;class value_t &gt; </td></tr>
<tr class="memitem:aa5a3504fca0e594d7f3a6cbb2a9684ef"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aa5a3504fca0e594d7f3a6cbb2a9684ef">set_node_property</a> (value_t(gmNodeProp::*m), const value_t &amp;value, <a class="el" href="classgm_selector.html">gmSelector</a> nodes=gmNODE_AUTO)</td></tr>
<tr class="memdesc:aa5a3504fca0e594d7f3a6cbb2a9684ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a property associated with the node(s).  <a href="#aa5a3504fca0e594d7f3a6cbb2a9684ef">More...</a><br /></td></tr>
<tr class="separator:aa5a3504fca0e594d7f3a6cbb2a9684ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2bc1ab5aa3647d8542e59aa28bf432"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab2bc1ab5aa3647d8542e59aa28bf432"></a>
vector&lt; std::string &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aab2bc1ab5aa3647d8542e59aa28bf432">node_data_by_id</a> (gmNodeID id=gmNODE_AUTO)</td></tr>
<tr class="memdesc:aab2bc1ab5aa3647d8542e59aa28bf432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to string data property of the node, or NULL if <em>id</em> is invalid. <br /></td></tr>
<tr class="separator:aab2bc1ab5aa3647d8542e59aa28bf432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0394b8c85706627941a27edfc0d47575"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0394b8c85706627941a27edfc0d47575"></a>
template&lt;class value_t &gt; </td></tr>
<tr class="memitem:a0394b8c85706627941a27edfc0d47575"><td class="memTemplItemLeft" align="right" valign="top">value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a0394b8c85706627941a27edfc0d47575">get_node_property_by_id</a> (value_t(gmNodeProp::*m), gmNodeID nid) const </td></tr>
<tr class="memdesc:a0394b8c85706627941a27edfc0d47575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation modes: construction<br />
. <br /></td></tr>
<tr class="separator:a0394b8c85706627941a27edfc0d47575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e3e6edf31e232f4003cb03289ebe8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40e3e6edf31e232f4003cb03289ebe8b"></a>
<a class="el" href="gmnode_8h.html#a237b2b5717b33780e79717450fff8faa">gmERROR_CODES</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a40e3e6edf31e232f4003cb03289ebe8b">get_node_error_by_id</a> (gmNodeID nid, std::string *message=NULL) const </td></tr>
<tr class="memdesc:a40e3e6edf31e232f4003cb03289ebe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets error status (one of <a class="el" href="gmnode_8h.html#a237b2b5717b33780e79717450fff8faa">gmERROR_CODES</a>) currently associated with the node and optionally the error message Operation modes: construction<br />
. <br /></td></tr>
<tr class="separator:a40e3e6edf31e232f4003cb03289ebe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ba890285d314966ac7d5e661112a05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a62ba890285d314966ac7d5e661112a05">set_node_resource</a> (const std::string &amp;resource_name, <a class="el" href="classgm_selector.html">gmSelector</a> nodes=gmNODE_AUTO)</td></tr>
<tr class="memdesc:a62ba890285d314966ac7d5e661112a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets resource associated with the node(s).  <a href="#a62ba890285d314966ac7d5e661112a05">More...</a><br /></td></tr>
<tr class="separator:a62ba890285d314966ac7d5e661112a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d9ccbd40706c04a4990d9c410524e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a22d9ccbd40706c04a4990d9c410524e0">set_node_name</a> (const std::string &amp;newname, <a class="el" href="classgm_selector.html">gmSelector</a> nodes=gmNODE_AUTO)</td></tr>
<tr class="memdesc:a22d9ccbd40706c04a4990d9c410524e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new name to selected node(s).  <a href="#a22d9ccbd40706c04a4990d9c410524e0">More...</a><br /></td></tr>
<tr class="separator:a22d9ccbd40706c04a4990d9c410524e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a190b9afdc5beb6b225f0355d91c3ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a6a190b9afdc5beb6b225f0355d91c3ab">block</a> (const string &amp;blockname, bool cond=true)</td></tr>
<tr class="memdesc:a6a190b9afdc5beb6b225f0355d91c3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a logical node block (currently affects graph output only).  <a href="#a6a190b9afdc5beb6b225f0355d91c3ab">More...</a><br /></td></tr>
<tr class="separator:a6a190b9afdc5beb6b225f0355d91c3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefecf15d48aad2ae4831cd36c6ffc989"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aefecf15d48aad2ae4831cd36c6ffc989">make_node_group</a> (<a class="el" href="classgm_selector.html">gmSelector</a> nodes)</td></tr>
<tr class="memdesc:aefecf15d48aad2ae4831cd36c6ffc989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group nodes together: the grouped nodes will share working directory under the same user.  <a href="#aefecf15d48aad2ae4831cd36c6ffc989">More...</a><br /></td></tr>
<tr class="separator:aefecf15d48aad2ae4831cd36c6ffc989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8694c6e9f80855cb69dcaf6e0512e3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ab8694c6e9f80855cb69dcaf6e0512e3c">assign_to_group</a> (int groupid, <a class="el" href="classgm_selector.html">gmSelector</a> nodes)</td></tr>
<tr class="memdesc:ab8694c6e9f80855cb69dcaf6e0512e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign nodes to the existing group: the grouped nodes will share working directory under the same user.  <a href="#ab8694c6e9f80855cb69dcaf6e0512e3c">More...</a><br /></td></tr>
<tr class="separator:ab8694c6e9f80855cb69dcaf6e0512e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b12bf3648581897151bde4700b3b72f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a0b12bf3648581897151bde4700b3b72f">set_node_action</a> (const <a class="el" href="classgm_node_action.html">gmNodeAction</a> &amp;action, <a class="el" href="classgm_selector.html">gmSelector</a> nodes=gmNODE_AUTO)</td></tr>
<tr class="memdesc:a0b12bf3648581897151bde4700b3b72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an action object associated with the node(s).  <a href="#a0b12bf3648581897151bde4700b3b72f">More...</a><br /></td></tr>
<tr class="separator:a0b12bf3648581897151bde4700b3b72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71434d59d0dbc0661205ff7093379464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a71434d59d0dbc0661205ff7093379464">set_node_action</a> (const std::string &amp;command, <a class="el" href="classgm_selector.html">gmSelector</a> nodes=gmNODE_AUTO)</td></tr>
<tr class="memdesc:a71434d59d0dbc0661205ff7093379464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an action command associated with the node(s).  <a href="#a71434d59d0dbc0661205ff7093379464">More...</a><br /></td></tr>
<tr class="separator:a71434d59d0dbc0661205ff7093379464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583843529705bd8819198cda23d5d307"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a583843529705bd8819198cda23d5d307">set_node_state</a> (enum gmNODE_STATES state, <a class="el" href="classgm_selector.html">gmSelector</a> nodes=gmNODE_AUTO)</td></tr>
<tr class="memdesc:a583843529705bd8819198cda23d5d307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually assign a state to the node(s).  <a href="#a583843529705bd8819198cda23d5d307">More...</a><br /></td></tr>
<tr class="separator:a583843529705bd8819198cda23d5d307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe8af09be31784012269c1c5ff63268"><td class="memItemLeft" align="right" valign="top">enum gmNODE_STATES&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a1fe8af09be31784012269c1c5ff63268">get_node_state_by_id</a> (gmNodeID nid) const </td></tr>
<tr class="separator:a1fe8af09be31784012269c1c5ff63268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c67f9b6e8b6d1b60902e033c0b7450"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66c67f9b6e8b6d1b60902e033c0b7450"></a>
gmNodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a66c67f9b6e8b6d1b60902e033c0b7450">set_autolink_node</a> (gmNodeID <a class="el" href="classgm_manager.html#a40868e358be246e24156644747ba9871">node</a>=-1)</td></tr>
<tr class="memdesc:a66c67f9b6e8b6d1b60902e033c0b7450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a node which will be autmatically linked by creation of a new node. <br /></td></tr>
<tr class="separator:a66c67f9b6e8b6d1b60902e033c0b7450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6631ae5803affdef1ee92e5eb522948"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ae6631ae5803affdef1ee92e5eb522948">clean_jobs</a> ()</td></tr>
<tr class="memdesc:ae6631ae5803affdef1ee92e5eb522948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans persistent nodal jobs from all resources.  <a href="#ae6631ae5803affdef1ee92e5eb522948">More...</a><br /></td></tr>
<tr class="separator:ae6631ae5803affdef1ee92e5eb522948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71a4a215cc5027dad865f4c15367be9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#af71a4a215cc5027dad865f4c15367be9">fetch_workdir_file</a> (int groupid, const std::string &amp;source, const std::string &amp;dest=&quot;&quot;)</td></tr>
<tr class="memdesc:af71a4a215cc5027dad865f4c15367be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as fetch_workdir_files but for single file.  <a href="#af71a4a215cc5027dad865f4c15367be9">More...</a><br /></td></tr>
<tr class="separator:af71a4a215cc5027dad865f4c15367be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e33c833470bc44ea3cb594efeb5102"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#af2e33c833470bc44ea3cb594efeb5102">fetch_node_file</a> (<a class="el" href="classgm_selector.html">gmSelector</a> nodes, const std::string &amp;source, const std::string &amp;dest=&quot;&quot;)</td></tr>
<tr class="memdesc:af2e33c833470bc44ea3cb594efeb5102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as fetch_node_files but for single file.  <a href="#af2e33c833470bc44ea3cb594efeb5102">More...</a><br /></td></tr>
<tr class="separator:af2e33c833470bc44ea3cb594efeb5102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276d596d3e00fe72c9342c038a27ee4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a276d596d3e00fe72c9342c038a27ee4f">set_fetch_on_fail</a> (bool flag)</td></tr>
<tr class="memdesc:a276d596d3e00fe72c9342c038a27ee4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to <em>true</em>, an attempt is always made to fetch link files from a remote node after node job is run, even if the node job has failed.  <a href="#a276d596d3e00fe72c9342c038a27ee4f">More...</a><br /></td></tr>
<tr class="separator:a276d596d3e00fe72c9342c038a27ee4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05edcf23d434bc1fbfeb11820705e4f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a05edcf23d434bc1fbfeb11820705e4f5">set_max_node_restarts</a> (int number)</td></tr>
<tr class="memdesc:a05edcf23d434bc1fbfeb11820705e4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of restart efforts after node failure.  <a href="#a05edcf23d434bc1fbfeb11820705e4f5">More...</a><br /></td></tr>
<tr class="separator:a05edcf23d434bc1fbfeb11820705e4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b5e784aa37291b3c9f1bf58d14593b"><td class="memItemLeft" align="right" valign="top">const vector&lt; std::pair&lt; gmNodeID, gmNODE_STATES &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a46b5e784aa37291b3c9f1bf58d14593b">get_event_stack</a> () const </td></tr>
<tr class="memdesc:a46b5e784aa37291b3c9f1bf58d14593b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current event stack.  <a href="#a46b5e784aa37291b3c9f1bf58d14593b">More...</a><br /></td></tr>
<tr class="separator:a46b5e784aa37291b3c9f1bf58d14593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cff752813d26edfdbd8226a501b1604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a8cff752813d26edfdbd8226a501b1604">job_state_changed</a> () const </td></tr>
<tr class="separator:a8cff752813d26edfdbd8226a501b1604"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a43fae4d2c3d176037cdbe2b4ea7ca278"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a43fae4d2c3d176037cdbe2b4ea7ca278">create_jobs</a> (int &amp;<a class="el" href="classgm_manager.html#a34755588cab646f900a8e3e1ac2ea632">graph_error</a>)</td></tr>
<tr class="memdesc:a43fae4d2c3d176037cdbe2b4ea7ca278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates job <em>threads</em> from a graph (makes one graph iteration).  <a href="#a43fae4d2c3d176037cdbe2b4ea7ca278">More...</a><br /></td></tr>
<tr class="separator:a43fae4d2c3d176037cdbe2b4ea7ca278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb4adf4532347c78094ace570fe474"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ac3fb4adf4532347c78094ace570fe474">queue_jobs</a> ()</td></tr>
<tr class="memdesc:ac3fb4adf4532347c78094ace570fe474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the jobs from <em>threads</em> into execution queue.  <a href="#ac3fb4adf4532347c78094ace570fe474">More...</a><br /></td></tr>
<tr class="separator:ac3fb4adf4532347c78094ace570fe474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e9be85f82fe739e6143dd35c2a1e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a335e9be85f82fe739e6143dd35c2a1e8">check_jobs</a> (size_t *<a class="el" href="classgm_manager.html#a13ac64c3dc481011d11112822413a59f">nfailed</a>=NULL)</td></tr>
<tr class="memdesc:a335e9be85f82fe739e6143dd35c2a1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if job list is empty or if some of the jobs are finished.  <a href="#a335e9be85f82fe739e6143dd35c2a1e8">More...</a><br /></td></tr>
<tr class="separator:a335e9be85f82fe739e6143dd35c2a1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02efb4658d68521aee3cf047e5e7f6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab02efb4658d68521aee3cf047e5e7f6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ab02efb4658d68521aee3cf047e5e7f6e">dump_data</a> ()</td></tr>
<tr class="memdesc:ab02efb4658d68521aee3cf047e5e7f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all repository data. <br /></td></tr>
<tr class="separator:ab02efb4658d68521aee3cf047e5e7f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db95c3d9f570546159196990979b53f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8db95c3d9f570546159196990979b53f"></a>
template&lt;class data_t &gt; </td></tr>
<tr class="memitem:a8db95c3d9f570546159196990979b53f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a8db95c3d9f570546159196990979b53f">_get_data</a> (data_t **data, const string &amp;data_name, int update=1)</td></tr>
<tr class="memdesc:a8db95c3d9f570546159196990979b53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">1= OK -1 = no file -2 = wrong type <br /></td></tr>
<tr class="separator:a8db95c3d9f570546159196990979b53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8e355eb30090f05661831d561aaa5d97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e355eb30090f05661831d561aaa5d97"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a8e355eb30090f05661831d561aaa5d97">name</a></td></tr>
<tr class="memdesc:a8e355eb30090f05661831d561aaa5d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;name of the current experiment <br /></td></tr>
<tr class="separator:a8e355eb30090f05661831d561aaa5d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ee284ecd5f1528fc7f9a7e9a2a7d56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35ee284ecd5f1528fc7f9a7e9a2a7d56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a35ee284ecd5f1528fc7f9a7e9a2a7d56">have_start_node</a></td></tr>
<tr class="memdesc:a35ee284ecd5f1528fc7f9a7e9a2a7d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">id of the first node in distributed section ('start' or other was added), for compatibility with older versions <br /></td></tr>
<tr class="separator:a35ee284ecd5f1528fc7f9a7e9a2a7d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d576df3e6d585ae1f2a4e2412c2e2ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d576df3e6d585ae1f2a4e2412c2e2ea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a5d576df3e6d585ae1f2a4e2412c2e2ea">dprev</a></td></tr>
<tr class="memdesc:a5d576df3e6d585ae1f2a4e2412c2e2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">distance to previous node (default 1) <br /></td></tr>
<tr class="separator:a5d576df3e6d585ae1f2a4e2412c2e2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463f7a503f8e102f2ca92e0c954834bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a463f7a503f8e102f2ca92e0c954834bd"></a>
gmNodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a463f7a503f8e102f2ca92e0c954834bd">max_node</a></td></tr>
<tr class="memdesc:a463f7a503f8e102f2ca92e0c954834bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximal allowed nodeid (for working mode) <br /></td></tr>
<tr class="separator:a463f7a503f8e102f2ca92e0c954834bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce5b278146150fe5c6875ef4eac0a00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce5b278146150fe5c6875ef4eac0a00"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a6ce5b278146150fe5c6875ef4eac0a00">distr_node</a></td></tr>
<tr class="memdesc:a6ce5b278146150fe5c6875ef4eac0a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">start of the distributed node generation <br /></td></tr>
<tr class="separator:a6ce5b278146150fe5c6875ef4eac0a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46749a6f47ee78c0d2e337c9e5d7861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa46749a6f47ee78c0d2e337c9e5d7861"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aa46749a6f47ee78c0d2e337c9e5d7861">last_loaded_event</a></td></tr>
<tr class="memdesc:aa46749a6f47ee78c0d2e337c9e5d7861"><td class="mdescLeft">&#160;</td><td class="mdescRight">id of the last event loaded from saved event stack when restarting <br /></td></tr>
<tr class="separator:aa46749a6f47ee78c0d2e337c9e5d7861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad584cf6dd8ed6cfb1916dc1f7ef456c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad584cf6dd8ed6cfb1916dc1f7ef456c6"></a>
<a class="el" href="classgm_scheduler.html">gmScheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ad584cf6dd8ed6cfb1916dc1f7ef456c6">sched</a></td></tr>
<tr class="memdesc:ad584cf6dd8ed6cfb1916dc1f7ef456c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler for managing resources. <br /></td></tr>
<tr class="separator:ad584cf6dd8ed6cfb1916dc1f7ef456c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096cbc51cb8904649ce80ce7c21171e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a096cbc51cb8904649ce80ce7c21171e5"></a>
<a class="el" href="classgm_mutex.html">gmMutex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a096cbc51cb8904649ce80ce7c21171e5">mutex</a></td></tr>
<tr class="memdesc:a096cbc51cb8904649ce80ce7c21171e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to be used to lock access to file-soterd information, like *.xml state of claculation. <br /></td></tr>
<tr class="separator:a096cbc51cb8904649ce80ce7c21171e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34755588cab646f900a8e3e1ac2ea632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34755588cab646f900a8e3e1ac2ea632"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a34755588cab646f900a8e3e1ac2ea632">graph_error</a></td></tr>
<tr class="memdesc:a34755588cab646f900a8e3e1ac2ea632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that graph error (deadlock or such) happened during the execution. <br /></td></tr>
<tr class="separator:a34755588cab646f900a8e3e1ac2ea632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ac64c3dc481011d11112822413a59f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13ac64c3dc481011d11112822413a59f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a13ac64c3dc481011d11112822413a59f">nfailed</a></td></tr>
<tr class="memdesc:a13ac64c3dc481011d11112822413a59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of failed threads in the last call to <a class="el" href="classgm_manager.html#a5b3f9a543d08afe6f989b81ad8b49000">execute_iteration()</a> <br /></td></tr>
<tr class="separator:a13ac64c3dc481011d11112822413a59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79b9a81035d3fb1af53fea0a5f9a479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae79b9a81035d3fb1af53fea0a5f9a479"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ae79b9a81035d3fb1af53fea0a5f9a479">nfinished</a></td></tr>
<tr class="memdesc:ae79b9a81035d3fb1af53fea0a5f9a479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of finished threads in the last call to <a class="el" href="classgm_manager.html#a5b3f9a543d08afe6f989b81ad8b49000">execute_iteration()</a> <br /></td></tr>
<tr class="separator:ae79b9a81035d3fb1af53fea0a5f9a479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ddd7c24ad2115d8dc5aff912ddd7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a0ddd7c24ad2115d8dc5aff912ddd7d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a5a0ddd7c24ad2115d8dc5aff912ddd7d">nstarted</a></td></tr>
<tr class="memdesc:a5a0ddd7c24ad2115d8dc5aff912ddd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of started threads in the last call to <a class="el" href="classgm_manager.html#a5b3f9a543d08afe6f989b81ad8b49000">execute_iteration()</a> <br /></td></tr>
<tr class="separator:a5a0ddd7c24ad2115d8dc5aff912ddd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80316505296ffd7ad256bcff85d349f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80316505296ffd7ad256bcff85d349f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a80316505296ffd7ad256bcff85d349f0">max_node_restarts</a></td></tr>
<tr class="memdesc:a80316505296ffd7ad256bcff85d349f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of restarts after job fails allowed for a node. <br /></td></tr>
<tr class="separator:a80316505296ffd7ad256bcff85d349f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbe25b06abb05c434bae82a3e34b805"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbbe25b06abb05c434bae82a3e34b805"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#acbbe25b06abb05c434bae82a3e34b805">graph_update</a></td></tr>
<tr class="memdesc:acbbe25b06abb05c434bae82a3e34b805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graph write frequency: 0= never, 1=once, 2=after each change. <br /></td></tr>
<tr class="separator:acbbe25b06abb05c434bae82a3e34b805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9143976f6fcb4989f16b03a0d43dcba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9143976f6fcb4989f16b03a0d43dcba7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a9143976f6fcb4989f16b03a0d43dcba7">construct_only</a></td></tr>
<tr class="memdesc:a9143976f6fcb4989f16b03a0d43dcba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate that we want only to construct a graph. <br /></td></tr>
<tr class="separator:a9143976f6fcb4989f16b03a0d43dcba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac889bcdbbddbe70e613d0289f2c905c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac889bcdbbddbe70e613d0289f2c905c5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#ac889bcdbbddbe70e613d0289f2c905c5">wr_flags</a></td></tr>
<tr class="memdesc:ac889bcdbbddbe70e613d0289f2c905c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to indicate what information is needed in the graph picture. <br /></td></tr>
<tr class="separator:ac889bcdbbddbe70e613d0289f2c905c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82742d7e9af97ac0bb12bcd040b911c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82742d7e9af97ac0bb12bcd040b911c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a82742d7e9af97ac0bb12bcd040b911c8">start_as_worker</a></td></tr>
<tr class="memdesc:a82742d7e9af97ac0bb12bcd040b911c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate that girdmd_main is a standalone worker. <br /></td></tr>
<tr class="separator:a82742d7e9af97ac0bb12bcd040b911c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538388ec15a540a836e0a745ca6e7f28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a538388ec15a540a836e0a745ca6e7f28"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a538388ec15a540a836e0a745ca6e7f28">full_restart</a></td></tr>
<tr class="memdesc:a538388ec15a540a836e0a745ca6e7f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate that we have to repeat all local nodes when restarting (-R command line option). <br /></td></tr>
<tr class="separator:a538388ec15a540a836e0a745ca6e7f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85af5d38509e965311fc81a98caabc08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85af5d38509e965311fc81a98caabc08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a85af5d38509e965311fc81a98caabc08">fetch_on_fail</a></td></tr>
<tr class="memdesc:a85af5d38509e965311fc81a98caabc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, always try to fetch output files connected to jobs, even on job failure. <br /></td></tr>
<tr class="separator:a85af5d38509e965311fc81a98caabc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41662c377526592d4d11c86be0b6664"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa41662c377526592d4d11c86be0b6664"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#aa41662c377526592d4d11c86be0b6664">entered_exec</a></td></tr>
<tr class="memdesc:aa41662c377526592d4d11c86be0b6664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that we are executing in local mode inside <a class="el" href="classgm_manager.html#ad1a18809cb1eb99fa2f63e2b36b903c6" title="Executes workflow graph from its current state. ">execute()</a>. Used to check when temporarily switching to construction mode. <br /></td></tr>
<tr class="separator:aa41662c377526592d4d11c86be0b6664"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a5355e3f9ea9db34adaba47c45b8d3929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5355e3f9ea9db34adaba47c45b8d3929"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_manager.html#a5355e3f9ea9db34adaba47c45b8d3929">rec_level</a> = 0</td></tr>
<tr class="memdesc:a5355e3f9ea9db34adaba47c45b8d3929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of recursion in <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec" title="User function to work with gridmd. ">gridmd_main()</a> calls. <br /></td></tr>
<tr class="separator:a5355e3f9ea9db34adaba47c45b8d3929"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa7715c047d53b67c6268ef28a4890704"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7715c047d53b67c6268ef28a4890704"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>gmScheduler</b></td></tr>
<tr class="separator:aa7715c047d53b67c6268ef28a4890704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c8eb686efe41a8ad4c8e151df01292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1c8eb686efe41a8ad4c8e151df01292"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>gmNodeAction</b></td></tr>
<tr class="separator:aa1c8eb686efe41a8ad4c8e151df01292"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main interface class to access workflow functions. </p>
<p>The default global instance of <a class="el" href="classgm_manager.html" title="Main interface class to access workflow functions. ">gmManager</a> is called <a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37">gmExperiment</a>. Many of the useful member calls to gmExperiment object may be performed the same way in the global scope (namespace gridmd), for example <a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37" title="Main experiment object. ">gmExperiment()</a>.mark_node("A") is equivalent to <a class="el" href="namespacegridmd.html#ad361b237c4472da1632f2d24b6b029c6" title="See gmManager::mark_node() ">gridmd::mark_node</a>("A") and to <a class="el" href="namespacegridmd.html#aeb3d7e818e9621c320531fa89e7c5450" title="See gmManager::mark_node() ">gridmd::node</a>("A") </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac99239279efc5792b3cd934b50cda26e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gmManager::gmManager </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>gmMODE_LOCAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_mutex.html">gmMutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em> = <code>&amp;gmMutex::voidMutex</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_manager_callback.html">gmManagerCallback</a> *&#160;</td>
          <td class="paramname"><em>call_back</em> = <code>&amp;gmManagerCallback::voidCallBack</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The optional <em>mode</em> parameter specifies the mode in which the <a class="el" href="classgm_manager.html" title="Main interface class to access workflow functions. ">gmManager</a> is created (one of gmMODES). Normally the default (gmMODE_LOCAL) should be used. The operation modes are then selectd automatically. Most of <a class="el" href="classgm_manager.html" title="Main interface class to access workflow functions. ">gmManager</a> functions work dependent on the execution mode. They also should be called from inside of <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main</a>(...) function. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae183940ff0cbed034cc1003442d2d4b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::add_resource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgm_resource_descr.html">gmResourceDescr</a> &amp;&#160;</td>
          <td class="paramname"><em>rdescr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the compute resource into the remote resource description list Default resource <em>name</em> is the same as hostname in the description. </p>
<p>Operation modes: local, construction (for explicit execution)<br />
 </p><dl class="section return"><dt>Returns</dt><dd>the number of currently existing resources (resource_id-1) on success, 0 if the mode is invalid, &lt;0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab8694c6e9f80855cb69dcaf6e0512e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::assign_to_group </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign nodes to the existing group: the grouped nodes will share working directory under the same user. </p>
<p>Assign nodes to the existing group: the grouped nodes will share working directory .</p>
<p>If the nodes belong to other groups, they will be reassigned. Resources for the grouped nodes are checked at time of execution to be operated by the same session (shell). </p><dl class="section return"><dt>Returns</dt><dd>group ID&gt;=0 on success, &lt;0 on failure Operation modes: construction<br />
</dd>
<dd>
group ID&gt;=0 on success, &lt;0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a72e62a1de7ce23910936c5286cd405aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::begin_distributed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Here begins the distributed portion of <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main</a>(...) that ends with <a class="el" href="classgm_manager.html#a2514f6c10286b47c248eccd802e8ced6">end_distributed()</a>. </p>
<p>There can be several distributed portions, but nesting of them is not allowed. This function adds the 'start' node to the graph, so processing of the start node (nodeid=0) should be performed if this function returns 1.<br />
 Operation modes: local, construction, worker<br />
 The course of execution after calling <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa" title="Here begins the distributed portion of gridmd_main(...) that ends with end_distributed(). ">begin_distributed()</a> depends on the execution mode (see <a class="el" href="classgm_manager.html#a12bc6c463b3e583b352737b527c208d8">set_execution()</a>). In the serial and construction_only execution mode the application proceeds normally. In the remote and local execution modes the main function <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main()</a> is called (recursed) from this function and proceeds in construction or local mode. </p><dl class="section return"><dt>Returns</dt><dd>1 in worker mode if 'start' node is passed </dd>
<dd>
0 in all other cases </dd></dl>

</div>
</div>
<a class="anchor" id="a6a190b9afdc5beb6b225f0355d91c3ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::block </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>blockname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cond</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a logical node block (currently affects graph output only). </p>
<p>[Operation modes: construction<br />
] </p>

</div>
</div>
<a class="anchor" id="a335e9be85f82fe739e6143dd35c2a1e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gmManager::check_jobs </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nfailed</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if job list is empty or if some of the jobs are finished. </p>
<p>Removes the finished jobs from <em>threads</em> and marks finished nodes as processed (PROC). </p>

</div>
</div>
<a class="anchor" id="ae6631ae5803affdef1ee92e5eb522948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t gmManager::clean_jobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans persistent nodal jobs from all resources. </p>
<dl class="section return"><dt>Returns</dt><dd>number of successfully cleaned jobs Operation modes: construction<br />
 Fetch files from the working directory of the specified workdir group. The vector <em>files</em> contains filename pairs {source_name, dest_name}, where <em>source_name</em> is the name on the (remote) resource, <em>dest_name</em> is the name on the local machine where the file should be placed. If <em>dest_name</em> is "" the same name as source in the local working directory is assumed. This function executes successfuly if the working directory is valid, i.e.:<br />
<ul>
<li>when at least one node of the group was submitted to execution AND<br />
</li>
<li>before <a class="el" href="classgm_manager.html#ae6631ae5803affdef1ee92e5eb522948" title="Cleans persistent nodal jobs from all resources. ">clean_jobs()</a> command was performed. </li>
</ul>
</dd>
<dd>
the number of fetched files on success or, -1 if workdir is not available &lt;-1 on other error; Operation modes: construction<br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="a43fae4d2c3d176037cdbe2b4ea7ca278"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gmManager::create_jobs </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>graph_error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates job <em>threads</em> from a graph (makes one graph iteration). </p>
<p><em>graph_error</em> is filled with nonzero error code in case of graph-related errors. </p><dl class="section return"><dt>Returns</dt><dd>true if there are more iterations needed to process/check remaining nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2514f6c10286b47c248eccd802e8ced6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class link_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::end_distributed </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;finish&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_NOOUTPUTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const link_type &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structgm_hard_link.html">gmHardLink</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Here ends the distributed part of the application that begins with <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa">begin_distributed()</a>. </p>
<p>This function adds the 'finish' node to the graph and connects all nodes without outputs constructed so far to the 'finish' node with hard links. The processing of the 'finish' node should be performed if this function returns 1. Note that this node is always local, so it (and all nodes connected with it by incoming hard links) is never transferred to a remote host for execution. Moreover, it is guranteed that the 'finish' node is performed by the same <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main()</a> instance that called <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa" title="Here begins the distributed portion of gridmd_main(...) that ends with end_distributed(). ">begin_distributed()</a> for the first time (the first <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main()</a> instance in fact). So local variables that existed before <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa">begin_distributed()</a> call have valid values and can be used when processing the 'finish' node and its hard-linked parents. Note that this is not true for other nodes including the 'start' node.<br />
 Operation modes: local, construction, worker<br />
 </p><dl class="section return"><dt>Returns</dt><dd>1 in worker mode if 'finish' node is passed </dd>
<dd>
0 in all other cases </dd></dl>

</div>
</div>
<a class="anchor" id="ad1a18809cb1eb99fa2f63e2b36b903c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::execute </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_schedules</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes workflow graph from its current state. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success if further execution is not needed (all done), 1 on success if there are unprocessed nodes, 2 on success if there are executing nodes -nfail on failure. In the last case nfail is the number of failed graph threads. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait</td><td>if true, waits till all nodes are processed or failed, otherwise returns after scheduling jobs (performs one execute iteration only) </td></tr>
    <tr><td class="paramname">cleanup</td><td>0 means no cleanup of jobs, -1= automatic, 1= yes </td></tr>
  </table>
  </dd>
</dl>
<p>!</p>
<p>! </p>

</div>
</div>
<a class="anchor" id="a5b3f9a543d08afe6f989b81ad8b49000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::execute_iteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs one sheduling iteration of workflow graph from its current state. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success if further execution is not needed (all done), 1 on success if there are unprocessed nodes, 2 on success if there are executing nodes -nfail on failure. In the last case nfail is the number of failed graph threads. </dd></dl>

</div>
</div>
<a class="anchor" id="af2e33c833470bc44ea3cb594efeb5102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::fetch_node_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as fetch_node_files but for single file. </p>
<p>Operation modes: construction<br />
 </p>

</div>
</div>
<a class="anchor" id="af71a4a215cc5027dad865f4c15367be9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::fetch_workdir_file </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as fetch_workdir_files but for single file. </p>
<p>Operation modes: construction<br />
 Fetch files from the nodes specified by a selector. The vector <em>files</em> contains filename pairs {source_name, dest_name}, where <em>source_name</em> is the name on the (remote) resource, <em>dest_name</em> is the name on the local machine where the file should be placed. If <em>dest_name</em> is "" the same name as source in the local working directory is assumed. This function executes successfuly for a node if the node is a part of a thread (job) with valid job directory, i.e.:<br />
</p><ul>
<li>the node is remote (job-managed) and has been submitted to execution AND<br />
</li>
<li>no <a class="el" href="classgm_manager.html#ae6631ae5803affdef1ee92e5eb522948" title="Cleans persistent nodal jobs from all resources. ">clean_jobs()</a> command was performed after finishing this node. <dl class="section return"><dt>Returns</dt><dd>the number of fetched files on success or, -1 if job workdir was not available for (all) listed node(s) &lt;-1 on other error; Operation modes: construction<br />
 </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a513d0b75131431de93aa8ed85af739ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gmEdgeID gmManager::find_edge </td>
          <td>(</td>
          <td class="paramtype">gmNodeID&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmNodeID&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds one edge by source and destination node ids. </p>
<dl class="section return"><dt>Returns</dt><dd>ID of an edge or gmEDGE_NONE if not found </dd></dl>

</div>
</div>
<a class="anchor" id="a0a3e4819dd0e59183dd9462d4863e462"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gmNodeID gmManager::find_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgm_selector.html">gmSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds one node mathching the selector. </p>
<dl class="section return"><dt>Returns</dt><dd>ID of a node or gmNODE_NONE if not found </dd></dl>

</div>
</div>
<a class="anchor" id="a46b5e784aa37291b3c9f1bf58d14593b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; std::pair&lt; gmNodeID, gmNODE_STATES &gt; &gt; &amp; gmManager::get_event_stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current event stack. </p>
<p>Node state changes are pusged_back to this vector in order of appearence. </p>

</div>
</div>
<a class="anchor" id="a1fe8af09be31784012269c1c5ff63268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum gmNODE_STATES gmManager::get_node_state_by_id </td>
          <td>(</td>
          <td class="paramtype">gmNodeID&#160;</td>
          <td class="paramname"><em>nid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>current node state, one of gmNODE_STATES </dd></dl>

</div>
</div>
<a class="anchor" id="af3abb879f63b695cdac6036e6e2050bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::get_recursion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns current gridmd_main recurison level between 0 and <a class="el" href="gridmd_8h.html#a450e276931e2754b3073ff99aa2e64c6">MAX_RECURSION</a>. </p>
<p>This is to take into account when handling global variables. </p>

</div>
</div>
<a class="anchor" id="ae50185cdbd222efa66bf8dba726dc08b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gmManager::in_construction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if the manager is in construction mode and in the current distributed section of the code, FALSE otherwise. </p>
<p>Used to program workflow skeletons for detecting the construction mode. </p>

</div>
</div>
<a class="anchor" id="a9280f4f429adcb0cdb1c0c3ab42c12ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::init </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">charDoublePtr &amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;gmexp&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical experiment initialization. </p>
<p>Local mode: initializes the experiment passing the command line parameters. For proper worker mode operation parameters <em>argc</em> and <em>argv</em> must be redirected from main() command line arguments. GridMD will interpret the following comand line parameters:<br />
 <em>-w&lt;node_list&gt;</em>, where <em>&lt;node_list&gt;</em> is a sequence of numbers delimited by ':' &ndash; a switch indicating worker mode with corresponding nodes execution request;<br />
 <em>-r</em> [xmlfile] &ndash; restart flag (manager mode only), xmlfile will be read as saved experiment configuration, 'expname.xml' is assumed when the file is not specified, where expname is the experiment name supplied to <a class="el" href="classgm_manager.html#a9280f4f429adcb0cdb1c0c3ab42c12ca">gmManager::init()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_</td><td>name for the current experiment which will be used to construct job names, and file names for saving configurations/checkpoints. Default is 'gmexp'. Other modes: does nothing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Local mode: 1 on success, &lt;0 otherwise </dd>
<dd>
Other modes: 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a614259fb328ff65f9395344ccceda3fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::init </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restart</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recalc_locals</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>restart_file_</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical experiment initialization (local manager mode only). </p>
<p>Local mode: initializes the experiment passing the parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_</td><td>name for the current experiment which will be used to construct job names, and file names for saving configurations/checkpoints. </td></tr>
    <tr><td class="paramname">restart</td><td>&ndash; restart flag, xmlfile will be read as saved experiment configuration </td></tr>
    <tr><td class="paramname">recalc_locals</td><td>&ndash; if restart flag is true, forces recalculation of all local nodes for saved configuration, otherwise no effect </td></tr>
    <tr><td class="paramname">restart_file</td><td>&ndash; if restart flag is true, name of xml file containig saved configuration, name.xml by default Other modes: does nothing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Local mode: 1 on success, &lt;0 otherwise </dd>
<dd>
Other modes: 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8cff752813d26edfdbd8226a501b1604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gmManager::job_state_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if there was a job state change (jobs finished, started or failed) during the last <a class="el" href="classgm_manager.html#a5b3f9a543d08afe6f989b81ad8b49000" title="Performs one sheduling iteration of workflow graph from its current state. ">execute_iteration()</a>, false otherwise (no jobs or waiting for existing jobs to finish). </dd></dl>

</div>
</div>
<a class="anchor" id="a06e06718033764221b07de7277f65c84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class data_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links the nodes indicated by selectors <em>from</em> and <em>to</em> with data or hard link. </p>
<p>Each of the selectors may have the following values (gmNODES):<br />
 &gt;=0 connect with the node having nodeID <em>input</em>,<br />
 gmNODE_NONE no links needed <br />
 gmNODE_ALL connect with all availbale nodes <br />
 gmNODE_PREV connect with the previously constructed node <br />
 gmNODE_NOOUTPUTS connect with nodes having no outputs so far <br />
 The link type is deduced from the template argument type, use link&lt;gmHardLink&gt; or link&lt;void&gt; for hard links, and link&lt;data_t&gt; for data links envolving transfer of data_t. For the data link a source port of a link may be indicated by a parameter <em>srcport</em>. The corresponding destination port (input port) is added automatically on the destination nodes. Operation modes: construction<br />
 </p><dl class="section return"><dt>Returns</dt><dd>1 on success, &lt;0 (and logs error) otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a501caf713de8f4c103c611c616eb8baf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::load_resources </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds compute resources found in the given XML file to the list of resources. </p>
<p>Searches for &lt;scheduler&gt; entries at top level of the file and loads resource descriptions from each of the &lt;resource&gt; child found. Operation modes: local<br />
 </p><dl class="section return"><dt>Returns</dt><dd>the number of successfully added resources. </dd></dl>

</div>
</div>
<a class="anchor" id="a259ad9e606b0bd489248aca49d31ab05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class link_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::local_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const link_type &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structgm_hard_link.html">gmHardLink</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a local node to the graph (construction mode), triggers processing of this node (worker mode). </p>
<p>Should be called inside distributed <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main()</a> section (between <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa">begin_distributed()</a> and <a class="el" href="classgm_manager.html#a2514f6c10286b47c248eccd802e8ced6">end_distributed()</a>). The parameters are arbitrary node <em>name</em> and the selector (gmNODES) telling how to conect this node with the previously constructed ones. The connection type is specified by a template parameter <em>link_type</em>, which can be either<br />
<a class="el" href="structgm_hard_link.html">gmHardLink</a> to indicate a hard link, or<br />
<a class="el" href="structgm_data_link.html">gmDataLink</a>&lt;data_t&gt; to indicate a data link envolving data of type data_t.<br />
For the data link a source port of a link may be indicated by a parameter <em>srcport</em>. The corresponding destination port (input port) is added automatically on the node being constructed. Selector <em>input</em> may have the following values:<br />
&gt;=0 connect with the node having nodeID <em>input</em>,<br />
gmNODE_NONE no links needed <br />
gmNODE_ALL connect with all availbale nodes <br />
gmNODE_PREV connect with the previously constructed node <br />
gmNODE_NOINPUTS connect with nodes having no inputs so far <br />
gmNODE_NOOUTPUTS connect with nodes having no outputs so far <br />
gmNODE_AUTO same as gmNODE_PREV Operation modes: construction, worker </p><dl class="section return"><dt>Returns</dt><dd>1 if this node has to be processed (worker mode only), 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aefecf15d48aad2ae4831cd36c6ffc989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::make_node_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Group nodes together: the grouped nodes will share working directory under the same user. </p>
<p>Group nodes together: the grouped nodes will share working directory .</p>
<p>If the nodes belong to other groups, they will be reassigned. Resources for the grouped nodes are checked at time of execution to be operated by the same session (shell). </p><dl class="section return"><dt>Returns</dt><dd>group ID&gt;=0 on success, &lt;0 on failure Operation modes: construction<br />
</dd>
<dd>
group ID&gt;=0 on success, &lt;0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="af226f7934194a6299fa47f2730e31f1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class link_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::mark_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const link_type &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structgm_hard_link.html">gmHardLink</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node to the graph (construction mode), triggers processing of this node (worker mode). </p>
<p>Should be called inside distributed <a class="el" href="gridmd_8h.html#a3419249a61b2e7f4abb21abf0a0f75ec">gridmd_main()</a> section (between <a class="el" href="classgm_manager.html#a72e62a1de7ce23910936c5286cd405aa">begin_distributed()</a> and <a class="el" href="classgm_manager.html#a2514f6c10286b47c248eccd802e8ced6">end_distributed()</a>). The parameters are arbitrary node <em>name</em> and the selector (gmNODES) telling how to conect this node with the previously constructed ones. The connection type is specified by a template parameter <em>link_type</em>, which can be either<br />
 <a class="el" href="structgm_hard_link.html">gmHardLink</a> to indicate a hard link, or<br />
 <a class="el" href="structgm_data_link.html">gmDataLink</a>&lt;data_t&gt; to indicate a data link envolving data of type data_t.<br />
 For the data link a source port of a link may be indicated by a parameter <em>srcport</em>. The corresponding destination port (input port) is added automatically on the node being constructed. Selector <em>input</em> may have the following values:<br />
 &gt;=0 connect with the node having nodeID <em>input</em>,<br />
 gmNODE_NONE no links needed <br />
 gmNODE_ALL connect with all availbale nodes <br />
 gmNODE_PREV connect with the previously constructed node <br />
 gmNODE_NOINPUTS connect with nodes having no inputs so far <br />
 gmNODE_NOOUTPUTS connect with nodes having no outputs so far <br />
 gmNODE_AUTO same as gmNODE_PREV Operation modes: construction, worker </p><dl class="section return"><dt>Returns</dt><dd>1 if this node has to be processed (worker mode only), 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a05bc6eecad57c0339d593971a41342c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class data_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const gmlink_traits&lt;data_t&gt;::value_type&amp; gmManager::node_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portid</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get input associated with given data port (default is 0) for the current node. </p>
<p>The data type must mutch the one indicated by link creation, otherwise a warning is given (at worker mode runtime) and temporary reference (whith garbage data) is returned. Operation modes: worker<br />
 Transfer of data corresponding to the input ports is performed by GridMD. This function performs data reading from a file transferred to a destination node and returns the reference to a variable which can be used as input in course of current node processing. </p><dl class="section return"><dt>Returns</dt><dd>a const reference to data_t for valid data types (excluding void). </dd></dl>

</div>
</div>
<a class="anchor" id="aaf1439d8828906822d14c9b924c55942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class data_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gmlink_traits&lt;data_t&gt;::value_type&amp; gmManager::node_output </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portid</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get output associated with given data port (default is 0) for the current node. </p>
<p>The data type must mutch the one indicated by link creation, otherwise the warning is given (at worker mode runtime) and temporary reference (not transferred anywhere by GridMD) is returned. Operation modes: worker<br />
 The transfer of data corresponding to the output ports is performed by GridMD. This function returns a reference to the variable which can be used as output in course of current node processing. When node processing is finished, the corresponding data file is written and transfered to the next destination node. </p><dl class="section return"><dt>Returns</dt><dd>a reference to data_t for valid data types (excluding void). </dd></dl>

</div>
</div>
<a class="anchor" id="a932e7f0624acc05d5205e198f565f785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::process_cur_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 only in worker mode and only when current node needs to be processed. </p>
<p>Otherwise returns 0. This function may be used alternatively to checking the return code of mark_node function when there are additional links to be added to the node before processing. </p>

</div>
</div>
<a class="anchor" id="ac3fb4adf4532347c78094ace570fe474"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gmManager::queue_jobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the jobs from <em>threads</em> into execution queue. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="a0a214ec07a5873474232350334772056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::save_resources </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves current list of compute resources into XML file. </p>
<p>Operation modes: local<br />
 </p><dl class="section return"><dt>Returns</dt><dd>&gt;0 for success, &lt;0 otherwise, 0 for wrong mode. </dd></dl>

</div>
</div>
<a class="anchor" id="ae45232368ce74f636612540243396e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::select_edges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; gmEdgeID &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destport</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects edges matching all pairs of source and destination node selectors. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of found edges. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf3121375700aee1680493f63060e2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::select_nodes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>input</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>def_port</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>closest_to</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects nodes/ports matching given selector into a std::pair vector {nodeid,portid}. Parameter <em>input</em> is not used currently. </p>
<p>Selects nodes into a vector. </p>

</div>
</div>
<a class="anchor" id="a12bc6c463b3e583b352737b527c208d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_execution </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>gmEXE_LOCAL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set execution mode (one of gmEXE_MODES). </p>
<p>Operation modes: local<br />
 Do not mix with operation mode! This parameters determines the way the experiment will be executed:<br />
 gmEXE_LOCAL: locally, recursively using the same application<br />
 gmEXE_REMOTE: on remote resource(s) which have to be configured by <a class="el" href="classgm_manager.html#ae183940ff0cbed034cc1003442d2d4b0">add_resource()</a><br />
 gmEXE_MIXED: mixing remote and local execution based on performance measurements (not implemented yet)<br />
 gmEXE_CONSTRUCT_ONLY: locally, skipping the node execution (for testing the graph integrity)<br />
 gmEXE_SERIAL: executes nodes locally just as they appear in the graph (in construction time), no recursive calls performed. This mode is not guaranteed to work properly because some links may be created after the node is added to the graph. In this case broken link warning is given at node execution. </p><dl class="section return"><dt>Returns</dt><dd>the previous setting of 0 for wrong mode </dd></dl>

</div>
</div>
<a class="anchor" id="a276d596d3e00fe72c9342c038a27ee4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gmManager::set_fetch_on_fail </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to <em>true</em>, an attempt is always made to fetch link files from a remote node after node job is run, even if the node job has failed. </p>
<dl class="section return"><dt>Returns</dt><dd>previous setting </dd></dl>

</div>
</div>
<a class="anchor" id="a01ba04aa8da009ef42eaf5aee43bb343"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_graphviz_flags </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>gmGV_ALL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets graphviz output flags (combination of gmGV_FIELDS). </p>
<p><br />
 Operation modes: local, construct<br />
 </p><dl class="section return"><dt>Returns</dt><dd>the previous setting </dd></dl>

</div>
</div>
<a class="anchor" id="aec152dc25f69890328cd26f690409c51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_graphviz_output </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switches automatic graphviz (dot) output modes: 0 = off, 1 = auto update in execute, 2 = auto update by each graph change <br />
 Operation modes: local, construct<br />
. </p>
<dl class="section return"><dt>Returns</dt><dd>the previous setting </dd></dl>

</div>
</div>
<a class="anchor" id="a007b92bdad63f1944279c26df7adf35f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_link_files </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file_flags</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit flags for temporary files handling modes (see gmTMP_FILES). </p>
<p>gmFILES_LOCAL: <br />
 Tells to create all link files even in the local mode. Note that restart (-R and -r command line options) in local mode will not produce correct results if this flag is not set.<br />
 gmFILES_CLEANUP: <br />
 Tells to cleanup all link files that are not in use (after connected nodes are processed). Note that full restart (-R command line option) may not be possible if this flag is on.<br />
 Operation modes: local<br />
 </p><dl class="section return"><dt>Returns</dt><dd>the previous setting </dd></dl>

</div>
</div>
<a class="anchor" id="a05edcf23d434bc1fbfeb11820705e4f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_max_node_restarts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum number of restart efforts after node failure. </p>
<dl class="section return"><dt>Returns</dt><dd>previous setting </dd></dl>

</div>
</div>
<a class="anchor" id="a0b12bf3648581897151bde4700b3b72f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_node_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgm_node_action.html">gmNodeAction</a> &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>gmNODE_AUTO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an action object associated with the node(s). </p>
<p>Set an action object associated with the node.</p>
<p>OnExecute() will be called for that object when node executes. </p><dl class="section return"><dt>Returns</dt><dd>Number of affected nodes. Operation modes: construction<br />
</dd></dl>
<p>OnExecute() will be called for that object when node executes. </p><dl class="section return"><dt>Returns</dt><dd>Number of affected nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a71434d59d0dbc0661205ff7093379464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_node_action </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>gmNODE_AUTO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an action command associated with the node(s). </p>
<p>Set an action command associated with the node. The command will be executed (locally or remotely) when node executes.</p>
<p>The command will be executed (locally or remotely) when node executes. </p><dl class="section return"><dt>Returns</dt><dd>Number of affected nodes. Operation modes: construction<br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="a22d9ccbd40706c04a4990d9c410524e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_node_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>gmNODE_AUTO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new name to selected node(s). </p>
<dl class="section return"><dt>Returns</dt><dd>Number of affected nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5a3504fca0e594d7f3a6cbb2a9684ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_node_property </td>
          <td>(</td>
          <td class="paramtype">value_t gmNodeProp::*&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>gmNODE_AUTO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a property associated with the node(s). </p>
<dl class="section return"><dt>Returns</dt><dd>Number of affected nodes. Operation modes: construction<br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="a62ba890285d314966ac7d5e661112a05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_node_resource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resource_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>gmNODE_AUTO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets resource associated with the node(s). </p>
<p>Resource with this name must have been added to <a class="el" href="classgm_manager.html" title="Main interface class to access workflow functions. ">gmManager</a> (see <a class="el" href="classgm_manager.html#ae183940ff0cbed034cc1003442d2d4b0">add_resource</a>) or loaded from XML at the time of execution. If assigned, the execution will be scheduled exactly to this resource, no automatic resource allocation happens. For hard-linked nodes with different resources a warning is given and the resource set for the first node in the thread is used. </p><dl class="section return"><dt>Returns</dt><dd>Number of affected nodes. Operation modes: construction<br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="a583843529705bd8819198cda23d5d307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::set_node_state </td>
          <td>(</td>
          <td class="paramtype">enum gmNODE_STATES&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>gmNODE_AUTO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually assign a state to the node(s). </p>
<p>The following states can be manually assigned only: gmNS_NO_NODE don't preassign any state for the node (the state assigned automatically, default behaviour) gmNS_UNPROC assign this to recalculate the node, <br />
 all dependent nodes are also automatically marked as unprocessed<br />
 gmNS_PROC mark the node as processed, all data associated with outgoing links must exist, for outgoing file links of remote nodes the file links should have names &lt;dest_filename&gt;.node&lt;remote_nodeid&gt;<br />
 gmNS_WAIT mark the node as delayed, no attempt to execute the node will be performed<br />
 gmNS_FAIL mark the node as failed </p><dl class="section return"><dt>Returns</dt><dd>Number of affected nodes, -1 if the selected state cannot be set manually Operation modes: construction<br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="a9d975deb3a44c8cd1dcfe3c75195c62c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::stop_all </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fetch_results</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops jobs for all executing nodes. </p>
<p>The stopped incomplete nodes are assigned gmNS_FAIL state. </p><dl class="section return"><dt>Returns</dt><dd>number of stopped jobs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fetch_results</td><td>if true, try to fetch the results for nodes being stopped. </td></tr>
    <tr><td class="paramname">cleanup</td><td>for stopped jobs: 0 means no cleanup of jobs, -1= automatic, 1= yes Operation modes: construction, worker<br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac97b97c47ac73259f2060521d8624dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::stop_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fetch_results</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops jobs for nodes matching a given selector in case they are executing. </p>
<p>The stopped incomplete nodes are assigned gmNS_FAIL state. </p><dl class="section return"><dt>Returns</dt><dd>number of stopped jobs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fetch_results</td><td>if true, try to fetch the results for nodes being stopped. </td></tr>
    <tr><td class="paramname">cleanup</td><td>for stopped jobs: 0 means no cleanup of jobs, -1= automatic, 1= yes Operation modes: construction, worker<br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac327a40c5e756ea35f922169403557f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gmManager::write_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the graph to corresponding file(s) (graphwiz, xml, etc). </p>
<p>Operation modes: local, construction </p><dl class="section return"><dt>Returns</dt><dd>&gt;0 for success, &lt;0 otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="gridmd_8h.html">gridmd.h</a></li>
<li>gridmd.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
