<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GridMD: gmFork&lt; split_tt, branch_tt, merge_tt &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GridMD
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgm_fork-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gmFork&lt; split_tt, branch_tt, merge_tt &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Skeleton class for concurrent branching.  
 <a href="classgm_fork.html#details">More...</a></p>

<p><code>#include &lt;gmsweep.h&gt;</code></p>
<div class="dynheader">
Collaboration diagram for gmFork&lt; split_tt, branch_tt, merge_tt &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classgm_fork__coll__graph.png" border="0" usemap="#gm_fork_3_01split__tt_00_01branch__tt_00_01merge__tt_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="gm_fork_3_01split__tt_00_01branch__tt_00_01merge__tt_01_4_coll__map" id="gm_fork_3_01split__tt_00_01branch__tt_00_01merge__tt_01_4_coll__map">
<area shape="rect" id="node2" href="classgm_manager.html" title="Main interface class to access workflow functions. " alt="" coords="343,171,433,197"/><area shape="rect" id="node6" href="classgm_scheduler.html" title="Scheduler managing different resources. " alt="" coords="611,103,709,129"/><area shape="rect" id="node3" href="classgm_manager_callback.html" title="Call&#45;back events, sent by gmManager. Set of events may be extended. " alt="" coords="31,44,171,71"/><area shape="rect" id="node4" href="classrefmap.html" title="refmap\&lt; string, gmLinkData \&gt;" alt="" coords="6,95,197,121"/><area shape="rect" id="node5" href="classmngptr.html" title="mngptr\&lt; gmNodeAction \&gt;" alt="" coords="17,145,186,172"/><area shape="rect" id="node7" href="classrefvector.html" title="refvector\&lt; gmShell \&gt;" alt="" coords="317,29,459,56"/><area shape="rect" id="node8" href="classrefvector.html" title="refvector\&lt; gmResource \&gt;" alt="" coords="305,80,471,107"/><area shape="rect" id="node9" href="structgm_node_prop.html" title="Properties of the node affected by the user configurable settings. " alt="" coords="53,196,150,223"/><area shape="rect" id="node10" href="classgm_mutex.html" title="mutex is used to lock access to file&#45;stored information, like &#39;restor file&#39; and &#39;*.dot graph&#39;. " alt="" coords="64,285,139,312"/><area shape="rect" id="node11" href="classint__pack.html" title="class for packing integers " alt="" coords="66,336,137,363"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0cb7d0f1da97362b23c9dc0e0a7fdef2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a0cb7d0f1da97362b23c9dc0e0a7fdef2">gmFork</a> (const string &amp;name_=&quot;&quot;, <a class="el" href="classgm_manager.html">gmManager</a> *manager=&amp;<a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37">gmExperiment</a>)</td></tr>
<tr class="memdesc:a0cb7d0f1da97362b23c9dc0e0a7fdef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the fork.  <a href="#a0cb7d0f1da97362b23c9dc0e0a7fdef2">More...</a><br/></td></tr>
<tr class="separator:a0cb7d0f1da97362b23c9dc0e0a7fdef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f115b55df784919dc8c8cca0f1d30ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f115b55df784919dc8c8cca0f1d30ec"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a2f115b55df784919dc8c8cca0f1d30ec">branchcount</a> () const </td></tr>
<tr class="memdesc:a2f115b55df784919dc8c8cca0f1d30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current number of branches in the fork (construction and worker mode). <br/></td></tr>
<tr class="separator:a2f115b55df784919dc8c8cca0f1d30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801caed242098ae040f6797fdc104c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a801caed242098ae040f6797fdc104c52">set_name</a> (const string &amp;name_=&quot;&quot;)</td></tr>
<tr class="memdesc:a801caed242098ae040f6797fdc104c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets/changes the name of the fork.  <a href="#a801caed242098ae040f6797fdc104c52">More...</a><br/></td></tr>
<tr class="separator:a801caed242098ae040f6797fdc104c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c163f307d64c7d34e5002878782df8"><td class="memTemplParams" colspan="2">template&lt;class link_type &gt; </td></tr>
<tr class="memitem:a08c163f307d64c7d34e5002878782df8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8">begin</a> (const string &amp;name_, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1)</td></tr>
<tr class="memdesc:a08c163f307d64c7d34e5002878782df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the top join node of the fork (begin node).  <a href="#a08c163f307d64c7d34e5002878782df8">More...</a><br/></td></tr>
<tr class="separator:a08c163f307d64c7d34e5002878782df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919ed6901ebe372b1918675e3ba73216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a919ed6901ebe372b1918675e3ba73216">begin</a> (const string &amp;name_=&quot;&quot;, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV)</td></tr>
<tr class="memdesc:a919ed6901ebe372b1918675e3ba73216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard link version of <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin&lt;&gt;()</a>.  <a href="#a919ed6901ebe372b1918675e3ba73216">More...</a><br/></td></tr>
<tr class="separator:a919ed6901ebe372b1918675e3ba73216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae874e31e8fbd3ea94284004b84c2c4b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#ae874e31e8fbd3ea94284004b84c2c4b8">begin_here</a> ()</td></tr>
<tr class="memdesc:ae874e31e8fbd3ea94284004b84c2c4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the fork with the current node whatever it is.  <a href="#ae874e31e8fbd3ea94284004b84c2c4b8">More...</a><br/></td></tr>
<tr class="separator:ae874e31e8fbd3ea94284004b84c2c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277dcd6bf0e1e012509c78f4bc1f05e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1">split</a> (const string &amp;name_=&quot;&quot;)</td></tr>
<tr class="memdesc:a277dcd6bf0e1e012509c78f4bc1f05e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new branch by creating a split node and linking it to the fork begin node with <em>split_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>).  <a href="#a277dcd6bf0e1e012509c78f4bc1f05e1">More...</a><br/></td></tr>
<tr class="separator:a277dcd6bf0e1e012509c78f4bc1f05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6573d2f12240fdd3f94c5afe41c46709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a6573d2f12240fdd3f94c5afe41c46709">split_here</a> ()</td></tr>
<tr class="memdesc:a6573d2f12240fdd3f94c5afe41c46709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a branch without creating a new node.  <a href="#a6573d2f12240fdd3f94c5afe41c46709">More...</a><br/></td></tr>
<tr class="separator:a6573d2f12240fdd3f94c5afe41c46709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee774f2030df4740f77a554303bfad03"><td class="memTemplParams" colspan="2">template&lt;class link_type &gt; </td></tr>
<tr class="memitem:aee774f2030df4740f77a554303bfad03"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03">merge</a> (const string &amp;name_, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1, bool same_ports=false)</td></tr>
<tr class="memdesc:aee774f2030df4740f77a554303bfad03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes current branch by creating a merge node.  <a href="#aee774f2030df4740f77a554303bfad03">More...</a><br/></td></tr>
<tr class="separator:aee774f2030df4740f77a554303bfad03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001851248c699c9a8e53b027fd9ea073"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a001851248c699c9a8e53b027fd9ea073">merge</a> (const string &amp;name=&quot;&quot;, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_AUTO, bool same_ports=false)</td></tr>
<tr class="memdesc:a001851248c699c9a8e53b027fd9ea073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic/Hard link version of <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03" title="Finishes current branch by creating a merge node. ">gmFork::merge&lt;&gt;()</a>.  <a href="#a001851248c699c9a8e53b027fd9ea073">More...</a><br/></td></tr>
<tr class="separator:a001851248c699c9a8e53b027fd9ea073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6c9b961b178dc5100f528183cde4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a8e6c9b961b178dc5100f528183cde4c4">merge_here</a> (bool same_ports=false)</td></tr>
<tr class="memdesc:a8e6c9b961b178dc5100f528183cde4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes current branch without creating a new node.  <a href="#a8e6c9b961b178dc5100f528183cde4c4">More...</a><br/></td></tr>
<tr class="separator:a8e6c9b961b178dc5100f528183cde4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5a31e92a8976c4f471e6119795e1a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a8b5a31e92a8976c4f471e6119795e1a6">end</a> (const string &amp;name_=&quot;&quot;, bool same_ports=false)</td></tr>
<tr class="memdesc:a8b5a31e92a8976c4f471e6119795e1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a final node where all branches join.  <a href="#a8b5a31e92a8976c4f471e6119795e1a6">More...</a><br/></td></tr>
<tr class="separator:a8b5a31e92a8976c4f471e6119795e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad460f5fc5c9d2021233fdad3f362a599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#ad460f5fc5c9d2021233fdad3f362a599">end_here</a> (bool same_ports=false)</td></tr>
<tr class="memdesc:ad460f5fc5c9d2021233fdad3f362a599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses current node as an end node of the fork.  <a href="#ad460f5fc5c9d2021233fdad3f362a599">More...</a><br/></td></tr>
<tr class="separator:ad460f5fc5c9d2021233fdad3f362a599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ef06d1566e631b03443e16393dd30d"><td class="memItemLeft" align="right" valign="top">split_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a08ef06d1566e631b03443e16393dd30d">vbegin_out</a> (int branchid) const </td></tr>
<tr class="memdesc:a08ef06d1566e631b03443e16393dd30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to split_tt to put the value of split data for branch <em>branchid</em>.  <a href="#a08ef06d1566e631b03443e16393dd30d">More...</a><br/></td></tr>
<tr class="separator:a08ef06d1566e631b03443e16393dd30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fdd2071b55e645581e0217bb8a6a77"><td class="memItemLeft" align="right" valign="top">const split_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#af4fdd2071b55e645581e0217bb8a6a77">vsplit_in</a> () const </td></tr>
<tr class="memdesc:af4fdd2071b55e645581e0217bb8a6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to split_tt to get the value of split data for current branch.  <a href="#af4fdd2071b55e645581e0217bb8a6a77">More...</a><br/></td></tr>
<tr class="separator:af4fdd2071b55e645581e0217bb8a6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74190cf00caad2cd600cdcaf2cedca6d"><td class="memItemLeft" align="right" valign="top">branch_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a74190cf00caad2cd600cdcaf2cedca6d">vsplit_out</a> ()</td></tr>
<tr class="memdesc:a74190cf00caad2cd600cdcaf2cedca6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to branch_tt to put the value of split data for current branch.  <a href="#a74190cf00caad2cd600cdcaf2cedca6d">More...</a><br/></td></tr>
<tr class="separator:a74190cf00caad2cd600cdcaf2cedca6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae727d580df437b95779497351daece0a"><td class="memItemLeft" align="right" valign="top">const branch_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#ae727d580df437b95779497351daece0a">vmerge_in</a> () const </td></tr>
<tr class="memdesc:ae727d580df437b95779497351daece0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to branch_tt to get the value of branch data for current branch.  <a href="#ae727d580df437b95779497351daece0a">More...</a><br/></td></tr>
<tr class="separator:ae727d580df437b95779497351daece0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce1475cf0e8d87063b6484bc5a2c7d"><td class="memItemLeft" align="right" valign="top">merge_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#aa0ce1475cf0e8d87063b6484bc5a2c7d">vmerge_out</a> (int portid=0)</td></tr>
<tr class="memdesc:aa0ce1475cf0e8d87063b6484bc5a2c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to merge_tt to put the value of merge data for current branch.  <a href="#aa0ce1475cf0e8d87063b6484bc5a2c7d">More...</a><br/></td></tr>
<tr class="separator:aa0ce1475cf0e8d87063b6484bc5a2c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2187ae0efb8ab7acc153da36b7d1dd8a"><td class="memItemLeft" align="right" valign="top">const merge_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a2187ae0efb8ab7acc153da36b7d1dd8a">vend_in</a> (int branchid) const </td></tr>
<tr class="memdesc:a2187ae0efb8ab7acc153da36b7d1dd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to merge_tt to get the value of merge data for branch <em>branchid</em>.  <a href="#a2187ae0efb8ab7acc153da36b7d1dd8a">More...</a><br/></td></tr>
<tr class="separator:a2187ae0efb8ab7acc153da36b7d1dd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be23550d6c3e989c4f3995b4887e847"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6be23550d6c3e989c4f3995b4887e847"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a6be23550d6c3e989c4f3995b4887e847">get_splitnode</a> (int branchid) const </td></tr>
<tr class="memdesc:a6be23550d6c3e989c4f3995b4887e847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a node ID of the split node in the branch <em>branchid</em>. <br/></td></tr>
<tr class="separator:a6be23550d6c3e989c4f3995b4887e847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb7d0f1da97362b23c9dc0e0a7fdef2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a0cb7d0f1da97362b23c9dc0e0a7fdef2">gmFork</a> (const string &amp;name_=&quot;&quot;, <a class="el" href="classgm_manager.html">gmManager</a> *manager=&amp;<a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37">gmExperiment</a>)</td></tr>
<tr class="memdesc:a0cb7d0f1da97362b23c9dc0e0a7fdef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the fork.  <a href="#a0cb7d0f1da97362b23c9dc0e0a7fdef2">More...</a><br/></td></tr>
<tr class="separator:a0cb7d0f1da97362b23c9dc0e0a7fdef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f115b55df784919dc8c8cca0f1d30ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f115b55df784919dc8c8cca0f1d30ec"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a2f115b55df784919dc8c8cca0f1d30ec">branchcount</a> () const </td></tr>
<tr class="memdesc:a2f115b55df784919dc8c8cca0f1d30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current number of branches in the fork (construction and worker mode). <br/></td></tr>
<tr class="separator:a2f115b55df784919dc8c8cca0f1d30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801caed242098ae040f6797fdc104c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a801caed242098ae040f6797fdc104c52">set_name</a> (const string &amp;name_=&quot;&quot;)</td></tr>
<tr class="memdesc:a801caed242098ae040f6797fdc104c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets/changes the name of the fork.  <a href="#a801caed242098ae040f6797fdc104c52">More...</a><br/></td></tr>
<tr class="separator:a801caed242098ae040f6797fdc104c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c163f307d64c7d34e5002878782df8"><td class="memTemplParams" colspan="2">template&lt;class link_type &gt; </td></tr>
<tr class="memitem:a08c163f307d64c7d34e5002878782df8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8">begin</a> (const string &amp;name_, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1)</td></tr>
<tr class="memdesc:a08c163f307d64c7d34e5002878782df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the top join node of the fork (begin node).  <a href="#a08c163f307d64c7d34e5002878782df8">More...</a><br/></td></tr>
<tr class="separator:a08c163f307d64c7d34e5002878782df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919ed6901ebe372b1918675e3ba73216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a919ed6901ebe372b1918675e3ba73216">begin</a> (const string &amp;name_=&quot;&quot;, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV)</td></tr>
<tr class="memdesc:a919ed6901ebe372b1918675e3ba73216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard link version of <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin&lt;&gt;()</a>.  <a href="#a919ed6901ebe372b1918675e3ba73216">More...</a><br/></td></tr>
<tr class="separator:a919ed6901ebe372b1918675e3ba73216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae874e31e8fbd3ea94284004b84c2c4b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#ae874e31e8fbd3ea94284004b84c2c4b8">begin_here</a> ()</td></tr>
<tr class="memdesc:ae874e31e8fbd3ea94284004b84c2c4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the fork with the current node whatever it is.  <a href="#ae874e31e8fbd3ea94284004b84c2c4b8">More...</a><br/></td></tr>
<tr class="separator:ae874e31e8fbd3ea94284004b84c2c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277dcd6bf0e1e012509c78f4bc1f05e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1">split</a> (const string &amp;name_=&quot;&quot;)</td></tr>
<tr class="memdesc:a277dcd6bf0e1e012509c78f4bc1f05e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new branch by creating a split node and linking it to the fork begin node with <em>split_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>).  <a href="#a277dcd6bf0e1e012509c78f4bc1f05e1">More...</a><br/></td></tr>
<tr class="separator:a277dcd6bf0e1e012509c78f4bc1f05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6573d2f12240fdd3f94c5afe41c46709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a6573d2f12240fdd3f94c5afe41c46709">split_here</a> ()</td></tr>
<tr class="memdesc:a6573d2f12240fdd3f94c5afe41c46709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a branch without creating a new node.  <a href="#a6573d2f12240fdd3f94c5afe41c46709">More...</a><br/></td></tr>
<tr class="separator:a6573d2f12240fdd3f94c5afe41c46709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee774f2030df4740f77a554303bfad03"><td class="memTemplParams" colspan="2">template&lt;class link_type &gt; </td></tr>
<tr class="memitem:aee774f2030df4740f77a554303bfad03"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03">merge</a> (const string &amp;name_, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_PREV, const link_type &amp;t=<a class="el" href="structgm_hard_link.html">gmHardLink</a>(), int srcport=-1, bool same_ports=false)</td></tr>
<tr class="memdesc:aee774f2030df4740f77a554303bfad03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes current branch by creating a merge node.  <a href="#aee774f2030df4740f77a554303bfad03">More...</a><br/></td></tr>
<tr class="separator:aee774f2030df4740f77a554303bfad03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001851248c699c9a8e53b027fd9ea073"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a001851248c699c9a8e53b027fd9ea073">merge</a> (const string &amp;name=&quot;&quot;, <a class="el" href="classgm_selector.html">gmSelector</a> input=gmNODE_AUTO, bool same_ports=false)</td></tr>
<tr class="memdesc:a001851248c699c9a8e53b027fd9ea073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic/Hard link version of <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03" title="Finishes current branch by creating a merge node. ">gmFork::merge&lt;&gt;()</a>.  <a href="#a001851248c699c9a8e53b027fd9ea073">More...</a><br/></td></tr>
<tr class="separator:a001851248c699c9a8e53b027fd9ea073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6c9b961b178dc5100f528183cde4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a8e6c9b961b178dc5100f528183cde4c4">merge_here</a> (bool same_ports=false)</td></tr>
<tr class="memdesc:a8e6c9b961b178dc5100f528183cde4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes current branch without creating a new node.  <a href="#a8e6c9b961b178dc5100f528183cde4c4">More...</a><br/></td></tr>
<tr class="separator:a8e6c9b961b178dc5100f528183cde4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5a31e92a8976c4f471e6119795e1a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a8b5a31e92a8976c4f471e6119795e1a6">end</a> (const string &amp;name_=&quot;&quot;, bool same_ports=false)</td></tr>
<tr class="memdesc:a8b5a31e92a8976c4f471e6119795e1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a final node where all branches join.  <a href="#a8b5a31e92a8976c4f471e6119795e1a6">More...</a><br/></td></tr>
<tr class="separator:a8b5a31e92a8976c4f471e6119795e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad460f5fc5c9d2021233fdad3f362a599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#ad460f5fc5c9d2021233fdad3f362a599">end_here</a> (bool same_ports=false)</td></tr>
<tr class="memdesc:ad460f5fc5c9d2021233fdad3f362a599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses current node as an end node of the fork.  <a href="#ad460f5fc5c9d2021233fdad3f362a599">More...</a><br/></td></tr>
<tr class="separator:ad460f5fc5c9d2021233fdad3f362a599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ef06d1566e631b03443e16393dd30d"><td class="memItemLeft" align="right" valign="top">split_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a08ef06d1566e631b03443e16393dd30d">vbegin_out</a> (int branchid) const </td></tr>
<tr class="memdesc:a08ef06d1566e631b03443e16393dd30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to split_tt to put the value of split data for branch <em>branchid</em>.  <a href="#a08ef06d1566e631b03443e16393dd30d">More...</a><br/></td></tr>
<tr class="separator:a08ef06d1566e631b03443e16393dd30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fdd2071b55e645581e0217bb8a6a77"><td class="memItemLeft" align="right" valign="top">const split_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#af4fdd2071b55e645581e0217bb8a6a77">vsplit_in</a> () const </td></tr>
<tr class="memdesc:af4fdd2071b55e645581e0217bb8a6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to split_tt to get the value of split data for current branch.  <a href="#af4fdd2071b55e645581e0217bb8a6a77">More...</a><br/></td></tr>
<tr class="separator:af4fdd2071b55e645581e0217bb8a6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74190cf00caad2cd600cdcaf2cedca6d"><td class="memItemLeft" align="right" valign="top">branch_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a74190cf00caad2cd600cdcaf2cedca6d">vsplit_out</a> ()</td></tr>
<tr class="memdesc:a74190cf00caad2cd600cdcaf2cedca6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to branch_tt to put the value of split data for current branch.  <a href="#a74190cf00caad2cd600cdcaf2cedca6d">More...</a><br/></td></tr>
<tr class="separator:a74190cf00caad2cd600cdcaf2cedca6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae727d580df437b95779497351daece0a"><td class="memItemLeft" align="right" valign="top">const branch_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#ae727d580df437b95779497351daece0a">vmerge_in</a> () const </td></tr>
<tr class="memdesc:ae727d580df437b95779497351daece0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to branch_tt to get the value of branch data for current branch.  <a href="#ae727d580df437b95779497351daece0a">More...</a><br/></td></tr>
<tr class="separator:ae727d580df437b95779497351daece0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce1475cf0e8d87063b6484bc5a2c7d"><td class="memItemLeft" align="right" valign="top">merge_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#aa0ce1475cf0e8d87063b6484bc5a2c7d">vmerge_out</a> (int portid=0)</td></tr>
<tr class="memdesc:aa0ce1475cf0e8d87063b6484bc5a2c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to merge_tt to put the value of merge data for current branch.  <a href="#aa0ce1475cf0e8d87063b6484bc5a2c7d">More...</a><br/></td></tr>
<tr class="separator:aa0ce1475cf0e8d87063b6484bc5a2c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2187ae0efb8ab7acc153da36b7d1dd8a"><td class="memItemLeft" align="right" valign="top">const merge_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a2187ae0efb8ab7acc153da36b7d1dd8a">vend_in</a> (int branchid) const </td></tr>
<tr class="memdesc:a2187ae0efb8ab7acc153da36b7d1dd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to merge_tt to get the value of merge data for branch <em>branchid</em>.  <a href="#a2187ae0efb8ab7acc153da36b7d1dd8a">More...</a><br/></td></tr>
<tr class="separator:a2187ae0efb8ab7acc153da36b7d1dd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be23550d6c3e989c4f3995b4887e847"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6be23550d6c3e989c4f3995b4887e847"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgm_fork.html#a6be23550d6c3e989c4f3995b4887e847">get_splitnode</a> (int branchid) const </td></tr>
<tr class="memdesc:a6be23550d6c3e989c4f3995b4887e847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a node ID of the split node in the branch <em>branchid</em>. <br/></td></tr>
<tr class="separator:a6be23550d6c3e989c4f3995b4887e847"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class split_tt = void, class branch_tt = split_tt, class merge_tt = branch_tt&gt;<br/>
class gmFork&lt; split_tt, branch_tt, merge_tt &gt;</h3>

<p>Skeleton class for concurrent branching. </p>
<p>Fork skeleton is used to split execution into several branches that may be run concurrently. The branches may have the same or different code. The skeleton has 4 building elements:<br/>
 <em>begin_node</em> &ndash; the node where the branches deviate from each other, only one begin node is possible for each fork;<br/>
 <em>split_node</em> &ndash; beginning of the branch, each branch (tooth) of the fork has one split node;<br/>
 <em>merge_node</em> &ndash; end of the branch, each branch (tooth) of the fork has one merge node. It may coincide with the split node;<br/>
 <em>end_node</em> &ndash; a node where the branches join, there may be 0, 1 or several end nodes of the fork.<br/>
 Template parameters are data types corresponding to the links between begin node and split nodes (<em>split_tt</em>) and merge nodes and end node (<em>merge_tt</em>). Also, if there are no added nodes between the split and merge nodes of the branch, and the split and merge nodes are different, a datalink of type <em>branch_tt</em> is automatically created. If any of the data types is <em>void</em>, then corresponding hard link is used. Node construction for the fork is performed by calling markup functions, for example <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8">gmFork::begin()</a> creates the begin node. All markup functions appear in two versions: the one creating a new node, and the other using the current node as building element of the fork. The second version markup functions end with <em>_here</em> postfix, for example <em>fork.begin_here()</em> will assign the current node as the begin node of <em>fork</em>. Usually the fork is constructed in the following sequence: <br/>
 <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin()</a> &ndash; adds begin node;<br/>
 <a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1" title="Starts a new branch by creating a split node and linking it to the fork begin node with split_tt data...">gmFork::split()</a> &ndash; adds a starting node of the new branch, links it with the begin node using <em>split_tt</em> datalink;<br/>
 <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c" title="Adds a node to the graph (construction mode), triggers processing of this node (worker mode)...">gmManager::mark_node()</a> &ndash; adds a node to this branch;<br/>
 <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c" title="Adds a node to the graph (construction mode), triggers processing of this node (worker mode)...">gmManager::mark_node()</a> &ndash; adds a node to this branch;<br/>
 ...<br/>
 <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03" title="Finishes current branch by creating a merge node. ">gmFork::merge()</a> &ndash; finishes this branch by adding a node which will be linked by <em>merge_tt</em> datalink with end node(s);<br/>
 <a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1" title="Starts a new branch by creating a split node and linking it to the fork begin node with split_tt data...">gmFork::split()</a> &ndash; adds another branch; <br/>
 ...<br/>
 <a class="el" href="classgm_fork.html#a8b5a31e92a8976c4f471e6119795e1a6" title="Adds a final node where all branches join. ">gmFork::end()</a> &ndash; adds an end node, links it with all merge nodes by <em>merge_t</em> datalink. Deviations from this sequence are also possible (fork with no end nodes, fork with multiple end nodes, parallel forks sharing some building elements, nested forks, etc.) The link data for all created nodes may be acessed in the usual way by <a class="el" href="namespacegridmd.html#a59a87f4fa1f40a0eca8bedf786d2ed21">gridmd::node_input&lt;&gt;()</a> and <a class="el" href="namespacegridmd.html#ac509f48fb7cc2a476c6e58350ef4d11d">gridmd::node_output&lt;&gt;()</a> functions. There is also a more type safe way of acessing this data by using the branch data access <a class="el" href="classgm_fork.html" title="Skeleton class for concurrent branching. ">gmFork</a> functions (<a class="el" href="classgm_fork.html#a74190cf00caad2cd600cdcaf2cedca6d">gmFork::vsplit_out()</a>, <a class="el" href="classgm_fork.html#af4fdd2071b55e645581e0217bb8a6a77">gmFork::vsplit_in()</a>, ... etc.) </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0cb7d0f1da97362b23c9dc0e0a7fdef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::<a class="el" href="classgm_fork.html">gmFork</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_manager.html">gmManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em> = <code>&amp;<a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37">gmExperiment</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the fork. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_</td><td>the name of the fork. By default constructs the name 'forkN', where N is the count of currently existing forks. The fork name is also used for naming the parant elements (like fork0.begin for begin node, etc.) if their names are not explicitly specified; </td></tr>
    <tr><td class="paramname">manager</td><td>is a pointer to managing object, defaults to the common <a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37">gmExperiment</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cb7d0f1da97362b23c9dc0e0a7fdef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::<a class="el" href="classgm_fork.html">gmFork</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_manager.html">gmManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em> = <code>&amp;<a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37">gmExperiment</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the fork. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_</td><td>the name of the fork. By default constructs the name 'forkN', where N is the count of currently existing forks. The fork name is also used for naming the parant elements (like fork0.begin for begin node, etc.) if their names are not explicitly specified; </td></tr>
    <tr><td class="paramname">manager</td><td>is a pointer to managing object, defaults to the common <a class="el" href="gridmd_8h.html#aac5272e13c4efd058d95a83a921d7c37">gmExperiment</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a08c163f307d64c7d34e5002878782df8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<div class="memtemplate">
template&lt;class link_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const link_type &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structgm_hard_link.html">gmHardLink</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the top join node of the fork (begin node). </p>
<p>The parameters and the return value are the same as for <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c">gmManager::mark_node()</a>, except for the name rule: if the <em>name_</em> is empty, the node is named &lt;fork_name&gt;.begin. As usual, the return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger begin node exection. If template parameter <em>split_tt</em> is not <em>void</em>, the created node will have an output dataport for each branch (indexed form 0, the number of branches is returned by <a class="el" href="classgm_fork.html#a2f115b55df784919dc8c8cca0f1d30ec">gmFork::branchcount()</a>). The dataports are accesible in the usual way by gmManager::node_output&lt;&gt;(portid) function. Alternatively, the link data may be output by using <a class="el" href="classgm_fork.html#a08ef06d1566e631b03443e16393dd30d">gmFork::vbegin_out()</a> function, allowing more accurate worker mode type control. All existing fork branches and their data is deleted by calling this function. The fork may be reinitialized for reuse by this function. </p>

</div>
</div>
<a class="anchor" id="a919ed6901ebe372b1918675e3ba73216"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hard link version of <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin&lt;&gt;()</a>. </p>
<p>Constructs incoming hard links from the nodes specified by <em>input</em>. </p>

</div>
</div>
<a class="anchor" id="a08c163f307d64c7d34e5002878782df8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<div class="memtemplate">
template&lt;class link_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const link_type &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structgm_hard_link.html">gmHardLink</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the top join node of the fork (begin node). </p>
<p>The parameters and the return value are the same as for <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c">gmManager::mark_node()</a>, except for the name rule: if the <em>name_</em> is empty, the node is named &lt;fork_name&gt;.begin. As usual, the return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger begin node exection. If template parameter <em>split_tt</em> is not <em>void</em>, the created node will have an output dataport for each branch (indexed form 0, the number of branches is returned by <a class="el" href="classgm_fork.html#a2f115b55df784919dc8c8cca0f1d30ec">gmFork::branchcount()</a>). The dataports are accesible in the usual way by gmManager::node_output&lt;&gt;(portid) function. Alternatively, the link data may be output by using <a class="el" href="classgm_fork.html#a08ef06d1566e631b03443e16393dd30d">gmFork::vbegin_out()</a> function, allowing more accurate worker mode type control. All existing fork branches and their data are deleted by calling this function. The fork may be reinitialized for reuse by this function. </p>

</div>
</div>
<a class="anchor" id="a919ed6901ebe372b1918675e3ba73216"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hard link version of <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin&lt;&gt;()</a>. </p>
<p>Constructs incoming hard links from the nodes specified by <em>input</em>. </p>

</div>
</div>
<a class="anchor" id="ae874e31e8fbd3ea94284004b84c2c4b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::begin_here </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins the fork with the current node whatever it is. </p>
<p>The output dataports (see <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin&lt;&gt;()</a>) are added to the current node. </p>

</div>
</div>
<a class="anchor" id="ae874e31e8fbd3ea94284004b84c2c4b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::begin_here </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins the fork with the current node whatever it is. </p>
<p>The output dataports (see <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin&lt;&gt;()</a>) are added to the current node. </p>

</div>
</div>
<a class="anchor" id="a8b5a31e92a8976c4f471e6119795e1a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a final node where all branches join. </p>
<p>If the <em>name_</em> is empty, the node is named '&lt;fork_name&gt;.end'. The return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger merge node exection. All existing branches (merge nodes or split nodes, if merge nodes are undefined) are linked to the end node with <em>merge_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). If template parameter <em>merge_tt</em> is not <em>void</em>, the merge node of each branch will have output dataports. The number of these dataports is controlled by <em>same_ports</em> parameter. If it is <em>true</em>, then the end node will be linked from the same (0th) dataport of the merge node. If it is <em>false</em>, then the end node will be linked from a separate dataport of each of the merge nodes. In this case each merge node will have an output dataport to this end node (its id corresponding to the order of end nodes creation). The dataports are accesible in the usual way by gmManager::node_output&lt;&gt;(portid) function. The end node has input data ports for each of the branches with ids matching the branch number starting form 0. If this function is never called for the fork, the fork remains open from the bottom and its ends may be explicitly linked with other nodes. </p>

</div>
</div>
<a class="anchor" id="a8b5a31e92a8976c4f471e6119795e1a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a final node where all branches join. </p>
<p>If the <em>name_</em> is empty, the node is named '&lt;fork_name&gt;.end'. The return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger merge node exection. All existing branches (merge nodes or split nodes, if merge nodes are undefined) are linked to the end node with <em>merge_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). If template parameter <em>merge_tt</em> is not <em>void</em>, the merge node of each branch will have output dataports. The number of these dataports is controlled by <em>same_ports</em> parameter. If it is <em>true</em>, then the end node will be linked from the same (0th) dataport of the merge node. If it is <em>false</em>, then the end node will be linked from a separate dataport of each of the merge nodes. In this case each merge node will have an output dataport to this end node (its id corresponding to the order of end nodes creation). The dataports are accesible in the usual way by gmManager::node_output&lt;&gt;(portid) function. The end node has input data ports for each of the branches with ids matching the branch number starting form 0. If this function is never called for the fork, the fork remains open from the bottom and its ends may be explicitly linked with other nodes. </p>

</div>
</div>
<a class="anchor" id="ad460f5fc5c9d2021233fdad3f362a599"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::end_here </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses current node as an end node of the fork. </p>
<p>The parameter <em>same_ports</em> controls the number of dataports created at merge nodes, see <a class="el" href="classgm_fork.html#a8b5a31e92a8976c4f471e6119795e1a6">gmFork::end()</a>. </p>

</div>
</div>
<a class="anchor" id="ad460f5fc5c9d2021233fdad3f362a599"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::end_here </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses current node as an end node of the fork. </p>
<p>The parameter <em>same_ports</em> controls the number of dataports created at merge nodes, see <a class="el" href="classgm_fork.html#a8b5a31e92a8976c4f471e6119795e1a6">gmFork::end()</a>. </p>

</div>
</div>
<a class="anchor" id="aee774f2030df4740f77a554303bfad03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<div class="memtemplate">
template&lt;class link_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const link_type &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structgm_hard_link.html">gmHardLink</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes current branch by creating a merge node. </p>
<p>First 4 parameters and the return value are the same as for <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c">gmManager::mark_node()</a>, except for the name rule: if the <em>name_</em> is empty, the node is named '&lt;fork_name&gt;.merge(N)',where N is the branch number. As usual, the return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger merge node exection. If input is gmNODE_AUTO and there is a split node for the current branch, then a datalink of type branch_tt is created between the split node and the merge node of the branch, ignoring the supplied link type. If end nodes already exist for this fork, the merge node is immediately linked to all of them with <em>merge_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). If template parameter <em>merge_tt</em> is not <em>void</em>, the created node will have output dataports. The number of these dataports is controlled by <em>same_ports</em> parameter. If it is <em>true</em>, then all end nodes will be linked from the same (0th) dataport of the merge node. If it is <em>false</em>, then each of the end nodes will be linked from a separate dataport of the merge node. In this case the merge node will have an output dataport for each end node (indexed form 0). The dataports are accesible in the usual way by gmManager::node_output&lt;&gt;(portid) function. If this function is not called for the branch, then the merge node coincides with the split node. </p>

</div>
</div>
<a class="anchor" id="a001851248c699c9a8e53b027fd9ea073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_AUTO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatic/Hard link version of <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03" title="Finishes current branch by creating a merge node. ">gmFork::merge&lt;&gt;()</a>. </p>
<p>If input is gmNODE_AUTO, then a datalink of type branch_tt is created between the split node and the merge node of the branch. Otherwise hard link(s) to the specified input node(s) are created. </p>

</div>
</div>
<a class="anchor" id="aee774f2030df4740f77a554303bfad03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<div class="memtemplate">
template&lt;class link_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_PREV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const link_type &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structgm_hard_link.html">gmHardLink</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcport</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes current branch by creating a merge node. </p>
<p>First 4 parameters and the return value are the same as for <a class="el" href="classgm_manager.html#af226f7934194a6299fa47f2730e31f1c">gmManager::mark_node()</a>, except for the name rule: if the <em>name_</em> is empty, the node is named '&lt;fork_name&gt;.merge(N)',where N is the branch number. As usual, the return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger merge node execution. If input is gmNODE_AUTO and there is a split node for the current branch, then a datalink of type branch_tt is created between the split node and the merge node of the branch, ignoring the supplied link type. If end nodes already exist for this fork, the merge node is immediately linked to all of them with <em>merge_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). If template parameter <em>merge_tt</em> is not <em>void</em>, the created node will have output dataports. The number of these dataports is controlled by <em>same_ports</em> parameter. If it is <em>true</em>, then all end nodes will be linked from the same (0th) dataport of the merge node. If it is <em>false</em>, then each of the end nodes will be linked from a separate dataport of the merge node. In this case the merge node will have an output dataport for each end node (indexed form 0). The dataports are accesible in the usual way by gmManager::node_output&lt;&gt;(portid) function. If this function is not called for the branch, then the merge node coincides with the split node. </p>

</div>
</div>
<a class="anchor" id="a001851248c699c9a8e53b027fd9ea073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgm_selector.html">gmSelector</a>&#160;</td>
          <td class="paramname"><em>input</em> = <code>gmNODE_AUTO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatic/Hard link version of <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03" title="Finishes current branch by creating a merge node. ">gmFork::merge&lt;&gt;()</a>. </p>
<p>If input is gmNODE_AUTO, then a datalink of type branch_tt is created between the split node and the merge node of the branch. Otherwise hard link(s) to the specified input node(s) are created. </p>

</div>
</div>
<a class="anchor" id="a8e6c9b961b178dc5100f528183cde4c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::merge_here </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes current branch without creating a new node. </p>
<p>Uses the current node as a merge node, creating output links. No input links are created. Same data ports as for <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03" title="Finishes current branch by creating a merge node. ">gmFork::merge()</a> are available. </p>

</div>
</div>
<a class="anchor" id="a8e6c9b961b178dc5100f528183cde4c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::merge_here </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_ports</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes current branch without creating a new node. </p>
<p>Uses the current node as a merge node, creating output links. No input links are created. Same data ports as for <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03" title="Finishes current branch by creating a merge node. ">gmFork::merge()</a> are available. </p>

</div>
</div>
<a class="anchor" id="a801caed242098ae040f6797fdc104c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::set_name </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets/changes the name of the fork. </p>
<p>By default or when the name is empty constructs the name 'forkN', where N is the count of currently existing forks. </p>

</div>
</div>
<a class="anchor" id="a801caed242098ae040f6797fdc104c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::set_name </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets/changes the name of the fork. </p>
<p>By default or when the name is empty constructs the name 'forkN', where N is the count of currently existing forks. </p>

</div>
</div>
<a class="anchor" id="a277dcd6bf0e1e012509c78f4bc1f05e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a new branch by creating a split node and linking it to the fork begin node with <em>split_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). </p>
<p>If <em>split_tt</em> is not <em>void</em>, one input data port of <em>split_tt</em> data is accessible by gmManager::node_input&lt;&gt;(0) function and contains the split data placed in the Nth output of the begin node, where N is the curren branch Id starting from zero. Alternatively, the link data may be obtained by using <a class="el" href="classgm_fork.html#af4fdd2071b55e645581e0217bb8a6a77">gmFork::vsplit_in()</a> function, allowing more accurate worker mode type control. If the name is empty the node is named '&lt;fork_name&gt;.split(N)', where N is the branch number. The return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger begin node exection. If <a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1" title="Starts a new branch by creating a split node and linking it to the fork begin node with split_tt data...">split()</a> is called before <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin()</a>, <a class="el" href="classgm_fork.html#ae874e31e8fbd3ea94284004b84c2c4b8" title="Begins the fork with the current node whatever it is. ">gmFork::begin_here()</a> is called for the current node. </p>

</div>
</div>
<a class="anchor" id="a277dcd6bf0e1e012509c78f4bc1f05e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name_</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a new branch by creating a split node and linking it to the fork begin node with <em>split_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). </p>
<p>If <em>split_tt</em> is not <em>void</em>, one input data port of <em>split_tt</em> data is accessible by gmManager::node_input&lt;&gt;(0) function and contains the split data placed in the Nth output of the begin node, where N is the curren branch Id starting from zero. Alternatively, the link data may be obtained by using <a class="el" href="classgm_fork.html#af4fdd2071b55e645581e0217bb8a6a77">gmFork::vsplit_in()</a> function, allowing more accurate worker mode type control. If the name is empty the node is named '&lt;fork_name&gt;.split(N)', where N is the branch number. The return value (nonzero for processing request in the worker mode, 0 otherwise) may be analyzed to trigger begin node exection. If <a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1" title="Starts a new branch by creating a split node and linking it to the fork begin node with split_tt data...">split()</a> is called before <a class="el" href="classgm_fork.html#a08c163f307d64c7d34e5002878782df8" title="Adds the top join node of the fork (begin node). ">gmFork::begin()</a>, <a class="el" href="classgm_fork.html#ae874e31e8fbd3ea94284004b84c2c4b8" title="Begins the fork with the current node whatever it is. ">gmFork::begin_here()</a> is called for the current node. </p>

</div>
</div>
<a class="anchor" id="a6573d2f12240fdd3f94c5afe41c46709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::split_here </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a branch without creating a new node. </p>
<p>Uses the current node as a split node and links it to the fork begin node with <em>split_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). Same data port as for <a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1" title="Starts a new branch by creating a split node and linking it to the fork begin node with split_tt data...">gmFork::split()</a> is available. </p>

</div>
</div>
<a class="anchor" id="a6573d2f12240fdd3f94c5afe41c46709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::split_here </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a branch without creating a new node. </p>
<p>Uses the current node as a split node and links it to the fork begin node with <em>split_tt</em> data link (or hard link when <em>split_tt</em> is <em>void</em>). Same data port as for <a class="el" href="classgm_fork.html#a277dcd6bf0e1e012509c78f4bc1f05e1" title="Starts a new branch by creating a split node and linking it to the fork begin node with split_tt data...">gmFork::split()</a> is available. </p>

</div>
</div>
<a class="anchor" id="a08ef06d1566e631b03443e16393dd30d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">split_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vbegin_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to split_tt to put the value of split data for branch <em>branchid</em>. </p>
<p>May be called at begin node only in worker mode. If called at wrong node or split_tt is void, a warning is given at worker mode runtime and a temporary reference for which no data transfer is possible is returned. </p>

</div>
</div>
<a class="anchor" id="a08ef06d1566e631b03443e16393dd30d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">split_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vbegin_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to split_tt to put the value of split data for branch <em>branchid</em>. </p>
<p>May be called at begin node only in worker mode. If called at wrong node or split_tt is void, a warning is given at worker mode runtime and a temporary reference for which no data transfer is possible is returned. </p>

</div>
</div>
<a class="anchor" id="a2187ae0efb8ab7acc153da36b7d1dd8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const merge_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vend_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to merge_tt to get the value of merge data for branch <em>branchid</em>. </p>
<p>May be called at end nodes only in worker mode. If called at wrong node or merge_tt is void, a warning is given at worker mode runtime and a temporary reference with garbage data is returned. </p>

</div>
</div>
<a class="anchor" id="a2187ae0efb8ab7acc153da36b7d1dd8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const merge_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vend_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to merge_tt to get the value of merge data for branch <em>branchid</em>. </p>
<p>May be called at end nodes only in worker mode. If called at wrong node or merge_tt is void, a warning is given at worker mode runtime and a temporary reference with garbage data is returned. </p>

</div>
</div>
<a class="anchor" id="ae727d580df437b95779497351daece0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const branch_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vmerge_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to branch_tt to get the value of branch data for current branch. </p>
<p>May be called at merge node (or at split node when there is no merge node) only in worker mode. If called at wrong node or branch_tt is void, a warning is given at worker mode runtime and a temporary reference with garbage data is returned. </p>

</div>
</div>
<a class="anchor" id="ae727d580df437b95779497351daece0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const branch_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vmerge_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to branch_tt to get the value of branch data for current branch. </p>
<p>May be called at merge node (or at split node when there is no merge node) only in worker mode. If called at wrong node or branch_tt is void, a warning is given at worker mode runtime and a temporary reference with garbage data is returned. </p>

</div>
</div>
<a class="anchor" id="aa0ce1475cf0e8d87063b6484bc5a2c7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">merge_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vmerge_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portid</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to merge_tt to put the value of merge data for current branch. </p>
<p>May be called at merge node (or at split node when there is no merge node) only in worker mode. If called at wrong node or merge_tt is void, a warning is given at worker mode runtime and a temporary reference for which no data transfer is possible is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portid</td><td>is a port number to put the data, usually corresponding to the end node this data is supplied to. See description of <em>same_ports</em> parameter of the <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03">gmFork::merge</a> function for detais. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0ce1475cf0e8d87063b6484bc5a2c7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">merge_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vmerge_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portid</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to merge_tt to put the value of merge data for current branch. </p>
<p>May be called at merge node (or at split node when there is no merge node) only in worker mode. If called at wrong node or merge_tt is void, a warning is given at worker mode runtime and a temporary reference for which no data transfer is possible is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portid</td><td>is a port number to put the data, usually corresponding to the end node this data is supplied to. See description of <em>same_ports</em> parameter of the <a class="el" href="classgm_fork.html#aee774f2030df4740f77a554303bfad03">gmFork::merge</a> function for detais. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4fdd2071b55e645581e0217bb8a6a77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const split_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vsplit_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to split_tt to get the value of split data for current branch. </p>
<p>May be called at split node only in worker mode. If called at wrong node or split_tt is void, a warning is given at worker mode runtime and a temporary reference with garbage data is returned. </p>

</div>
</div>
<a class="anchor" id="af4fdd2071b55e645581e0217bb8a6a77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const split_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vsplit_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to split_tt to get the value of split data for current branch. </p>
<p>May be called at split node only in worker mode. If called at wrong node or split_tt is void, a warning is given at worker mode runtime and a temporary reference with garbage data is returned. </p>

</div>
</div>
<a class="anchor" id="a74190cf00caad2cd600cdcaf2cedca6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">branch_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vsplit_out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to branch_tt to put the value of split data for current branch. </p>
<p>May be called at split node only in worker mode. If called at wrong node or branch_tt is void, a warning is given at worker mode runtime and a temporary reference for which no data transfer is possible is returned. </p>

</div>
</div>
<a class="anchor" id="a74190cf00caad2cd600cdcaf2cedca6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class split_tt  = void, class branch_tt  = split_tt, class merge_tt  = branch_tt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">branch_t&amp; <a class="el" href="classgm_fork.html">gmFork</a>&lt; split_tt, branch_tt, merge_tt &gt;::vsplit_out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to branch_tt to put the value of split data for current branch. </p>
<p>May be called at split node only in worker mode. If called at wrong node or branch_tt is void, a warning is given at worker mode runtime and a temporary reference for which no data transfer is possible is returned. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="gmfork_8h.html">gmfork.h</a></li>
<li>gmsweep.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
