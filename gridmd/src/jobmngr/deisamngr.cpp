/****************************************************************************
 * \file deisamngr.cpp
 * Implementation of Deisa Job Manager
****************************************************************************/

#include <wx/utils.h>
#include <wx/filefn.h>
#include <wx/filename.h>
#include <wx/ffile.h>
#include "jobmngr/deisamngr.h"


void DeisaManager::Open(pCSTR service, pCSTR user)
{
  // Read DeisaManager parameters
  deshl_server = "c:\\apps\\deshl\\bin\\deshl-server.bat";
  deshl_client = "c:\\apps\\deshl\\bin\\deshl-noninteract.bat";
  tar_path = "c:\\apps\\tar\\tar.exe";
  loc_tmp_dir = ".";
  rem_tmp_dir = "home";
  rem_tmp_var = "$HOME";
  rem_perm_dir = "deisa_home";
  rem_perm_var = "$DEISA_HOME";
  appname = "test";
  jobcounter = 1;

  // Initialize local class variables
  site = service;
  sitep = site + '/';
  
  // Append path separators to the directory names and spaces to the commands
  pathsep = wxFileName::GetPathSeparator();
  wxString pathseps = wxFileName::GetPathSeparators();
  if( pathseps.Find(loc_tmp_dir.Last()) == wxNOT_FOUND ) loc_tmp_dir += pathsep;
  if( rem_tmp_dir.Last() != '/' ) rem_tmp_dir += '/';
  if( rem_tmp_var.Last() != '/' ) rem_tmp_var += '/';
  if( rem_perm_dir.Last() != '/' ) rem_perm_dir += '/';
  if( rem_perm_var.Last() != '/' ) rem_perm_var += '/';
  if( deshl_client.Last() != ' ' ) deshl_client += ' ';
  if( tar_path.Last() != ' ' ) tar_path += ' ';

  // Try DESHL client
  if( DESHL_check_cmd() ) {
    // Start DESHL server when it's not running
    LOGJOBWARN("Starting DESHL server");
    server_pid = wxExecute(deshl_server, wxEXEC_ASYNC);
    if(!server_pid) LOGJOBERR(201, "Failed to start DESHL server.");

    // Check if DESHL client can connect to the server now
    const int max_attemps = 8;
    int i;
    for(i=0; i<max_attemps; i++) {
      wxSleep(10);
      if( !DESHL_check_cmd() ) break;
    }
    if(i == max_attemps) LOGJOBERR(202, "DESHL client cannot connect to the server.");
  }
  
  //wxArrayString out, err;
  //puts("===== stdout ======");
  //for(i=0; i<out.Count(); i++) puts( (pCSTR)(out[i]) );
  //
  //puts("===== stderr ======");
  //for(i=0; i<err.Count(); i++) puts( (pCSTR)(err[i]) );
}


void DeisaManager::Close()
{
  while( !jobs.empty() ) jobs.back()->Clear();

  if(server_pid){
    LOGJOBWARN("Terminating DESHL server");
    DESHL_cmd("quit");
    server_pid = 0;
  }
}


int DeisaManager::Submit(gmJob& job)
{
  // Create the structure for extra job information
  gmDeisaJobInfo* jobex = new gmDeisaJobInfo;
  job.extra = jobex;

  // Set job names and temporaty file names
  wxString jobname;
  jobname.Printf("%s-%d", appname.c_str(), jobcounter);
  wxString djobname = "DeisaJob-" + jobname;
  wxString locdir = loc_tmp_dir + djobname;
  wxString stinfile = djobname + "-in.tar";
  wxString stoutfile = djobname + "-out.tar";
  #ifdef _WIN32
  wxString tarcmd = tar_path + "-rhf " + locdir + pathsep + stinfile + " --mode=755 -C ";
  #else
  wxString tarcmd = tar_path + "-rhf " + locdir + pathsep + stinfile + " -C ";
  #endif
  wxString untarcmd = tar_path + "-xf " + locdir + pathsep + stoutfile + " -C ";
  jobex->locdir = locdir;
  jobex->stoutfile = djobname + "-out.tar";
  jobex->locdir_exists = false;

  // Create local temporary directory
  if( !wxMkdir(locdir) )
    LOGJOBERR(220, fmt("Temporary directory %s cannot be created.", locdir.c_str()) );
  jobex->locdir_exists = true;

  // Prepare job defintion file
  wxString jsdfile = djobname + "-script.sh";
  wxString jsd =
    "#!/bin/bash\x0A"
    "# SAGA Job Definition file generated by Deisa Job Manager\x0A"
    "#\x0A"
    "#$ SAGA_JobName = " + jobname + "\x0A"
    "#$ SAGA_JobCmd = " + jsdfile + "\x0A"
    "#$ SAGA_HostList = " + site + "\x0A"
    "#$ SAGA_FileTransfer = " + rem_tmp_var + jsdfile + " > " + jsdfile + "\x0A";

  if(job.ncpus) jsd += fmt("#$ SAGA_NumTasks = %d\x0A", job.ncpus);
  if(job.nthreads) jsd += fmt("#$ SAGA_NumCpus = %d\x0A", job.nthreads);
  if(job.walltime) jsd += fmt("#$ SAGA_WallClockSoftLimit = %d\x0A", job.walltime);
  jsd +=
    "\x0ASAVED_USPACE_DIR=$PWD\x0A"
    "rm -f " + rem_tmp_var + jsdfile + "\x0A";

  // Process input files
  int i, nfiles = job.infiles.Count(), nstagein = 0, nstageout = 0;
  wxString curfile;
  wxFileName fn;
  
  for(i=0; i<nfiles; i++) {
    // Analyze file name
    curfile = job.infiles[i];

    if( curfile.Last() == '@' ) {
      // File is in the remote filesystem: prepare to copy from script
      curfile.RemoveLast();
      jsd += "cp -R " + subst_perm(curfile, rem_perm_var) + " .\x0A";
    }
    else {
      // File is in the local filesystem: tar it
      nstagein++;
      fn.Assign(curfile);
      if( wxExecute(tarcmd + fn.GetPath() + ' ' + fn.GetFullName(), wxEXEC_SYNC) )
        LOGJOBERR(225, fmt("Unable to tar input file %s", curfile.c_str()) );
    }
  }

  // Upload input files and save the unpack commands
  if(nstagein) {
    StageIn(locdir + pathsep + stinfile, rem_tmp_dir);
    jsd += "tar -xf " + rem_tmp_var + stinfile + '\x0A';
    jsd += "rm -f " + rem_tmp_var + stinfile + '\x0A';
  }

  // Write user command
  jsd += job.command + "\x0A"
         "cd $SAVED_USPACE_DIR\x0A";

  // Process output files
  nfiles = job.outfiles.Count();
  jobex->untar_list.Clear();
  wxString tar_out_files;

  for(i=0; i<nfiles; i++) {
    // Analyze file name
    curfile = job.outfiles[i];

    if( curfile.Last() == '@' ) {
      // File is in the remote filesystem: prepare to copy from script
      curfile.RemoveLast();
      curfile = subst_perm(curfile, rem_perm_var);
      jsd += "cp -Rf " + curfile.AfterLast('/') + ' ' + curfile.BeforeLast('/') + '\x0A';
    }
    else {
      // File is in the local filesystem: untar it
      nstageout++;
      fn.Assign(curfile);
      jobex->untar_list.Add(untarcmd + fn.GetPath() + ' ' + fn.GetFullName());
      tar_out_files += fn.GetFullName() + " ";
    }
  }

  if(nstageout)
    jsd += "tar -chf " + rem_tmp_var + stoutfile + " " + tar_out_files;

  // Write submission script
  wxString jsdpath = locdir + pathsep + jsdfile;
  wxFFile ffile;
  if( !ffile.Open(jsdpath, "wb") )
    LOGJOBERR(222, fmt("Unable to create JDS file %s.", jsdfile.c_str()) );
  ffile.Write(jsd);
  ffile.Close();

  // Upload sctipt and submit job
  StageIn(jsdpath, rem_tmp_dir);
  DESHL_cmd("submit " + jsdpath, DESHL_OUTPUT);
  LOGJOBMSG(cmdout[0]);
  job.id = cmdout[0].Mid(10).BeforeFirst(',');
  if( !job.id.size() ) LOGJOBERR(224, "Illegal output from submit command." );

  // Insert into the list of active jobs
  jobs.push_back(&job);
  jobcounter++;

  return 0;
}


int DeisaManager::Status(gmJob& job)
{
  DESHL_cmd("status " + job.id, DESHL_OUTPUT);
  LOGJOBMSG(cmdout[0]);
  wxString s = cmdout[0].AfterLast(' ');
  if( !s.size() ) LOGJOBERR(230, "Illegal output from status command." );

  int state;
  if(s == "New") state = JOB_SUBMITTED;
  else if(s == "Running") state = JOB_RUNNING;
  else if(s == "Done") state = JOB_COMPLETED;
  else if(s == "Failed" || s == "Canceled") state = JOB_FAILED;
  else LOGJOBERR(230, "Illegal output from status command." );

  return state;
}


int DeisaManager::Wait(gmJob& job)
{
  int state = Status(job);

  while( state >= JOB_SUBMITTED && state < JOB_COMPLETED ) {
    wxSleep(5);
    state = Status(job);
  }

  return state;
}


void DeisaManager::Stop(gmJob& job)
{
  DESHL_cmd("terminate " + job.id);
}


int DeisaManager::FetchResult(gmJob& job)
{
  gmDeisaJobInfo* jobex = (gmDeisaJobInfo*)job.extra;
  DESHL_cmd("fetch -d " + jobex->locdir + " " + job.id);

  // Save stdout and stderr
  if( !job.stdoutf.empty() )
    wxCopyFile(jobex->locdir + pathsep + job.id + ".out", job.stdoutf);
  if( !job.stderrf.empty() )
    wxCopyFile(jobex->locdir + pathsep + job.id + ".err", job.stderrf);

  if( job.GetState() == JOB_FAILED ) return 1;

  // Stage out results
  int nfiles = jobex->untar_list.Count();
  if(nfiles) {
    StageOut(jobex->locdir, rem_tmp_dir + jobex->stoutfile, fMove);
    for(int i=0; i<nfiles; i++)
      if( wxExecute(jobex->untar_list[i], wxEXEC_SYNC) )
        LOGJOBERR(240, fmt("Unable to untar ouput file %s", jobex->untar_list[i].c_str()) );
  }

  return 0;
}


void DeisaManager::Clear(gmJob& job)
{
  gmDeisaJobInfo* jobex = (gmDeisaJobInfo*)job.extra;
  
  // Remove temporary directories
  if( jobex->locdir_exists ) RmDirTree(jobex->locdir);

  jobs.remove(&job);
}


void DeisaManager::MkDir(pCSTR remdir)
{
  int retcode = DESHL_cmd("mkdir -p " + sitep + subst_perm(remdir), DESHL_SKIP_ERR);
  if(retcode > 1)
    LOGJOBERR(210, fmt("DESHL failed for \"%s\", errcode = %d", deshl_cmd.c_str(), retcode));
}


void DeisaManager::StageIn(pCSTR locfile, pCSTR remfile, int type)
{
  DESHL_cmd( wxString(type == fCopy ? "cp -rf " : "mv -f ")
             + locfile + " " + sitep + subst_perm(remfile) );
}


void DeisaManager::StageOut(pCSTR locfile, pCSTR remfile, int type)
{
  wxRemoveFile(locfile);  // this avoids an error when the locfile exists
  DESHL_cmd( wxString(type == fCopy ? "cp " : "mv ")
               + sitep + subst_perm(remfile) + " " + locfile );
}


void DeisaManager::Remove(pCSTR remfile)
{
  DESHL_cmd( "rm -r " + sitep + subst_perm(remfile));
}


int DeisaManager::DESHL_cmd(wxString cmd, int flags)
{
  int retcode;
  deshl_cmd = cmd;
  LOGJOBMSG( fmt("DESHL %s", cmd) );

  if(flags & DESHL_OUTPUT) {
    cmdout.Empty();
    retcode = wxExecute(deshl_client + cmd, cmdout); 
    //for(unsigned i=0; i<cmdout.Count(); i++) LOGJOBMSG(cmdout[i]);
  }
  else retcode = wxExecute(deshl_client + cmd, wxEXEC_SYNC);

  if(retcode && !(flags & DESHL_SKIP_ERR) )
    LOGJOBERR(210, fmt("DESHL failed for \"%s\", errcode = %d", cmd.c_str(), retcode));

  if((flags & DESHL_OUTPUT & !retcode) && cmdout.Count() < 1)
    LOGJOBERR(223, "No output from DESHL command." );

  return retcode;
}


int DeisaManager::DESHL_check_cmd()
{
  LOGJOBMSG("Trying DESHL client ...");
  int retcode = DESHL_cmd("sites", DESHL_OUTPUT | DESHL_SKIP_ERR);
  if(!retcode) LOGJOBMSG("DESHL client is ok");

  if(retcode != 0 && retcode != 210)
    LOGJOBERR(210, fmt("Failed to execute DESHL client, errcode = %d.", retcode));
  return retcode;
}
