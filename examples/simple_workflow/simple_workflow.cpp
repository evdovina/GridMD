/****************************************************************************
 *
 *   Copyright (c), Ilya Valuev, Igor Morozov 2005-2010        All Rights Reserved.
 *
 *   Author	: Ilya Valuev, Igor Morozov, JIHT RAS, Moscow, Russia
 *
 *   Project	: GridMD
 *
 *   This source code is Free Software and distributed under the terms of GridMD license
 *   (gridmd\doc\gridmd_license.txt)
 *
 *   This example shows usage of the functions for creation and linking of the parts (nodes)
 *   of a distributed workflow. The nodes perform simple arithmetic calculations.
 *
 *****************************************************************************/


# include "gridmd.h"
# include "gmfork.h"
# include <cmath>


using namespace gridmd;


int main(int argc,char* argv[]){

  // wxWindows initialization
  if( !gmdInitialize() ) {
    puts("Failed to initialize the GridMD library.");
    return -1;
  }

  // The following command enables output of information messages (vblALLMESS),
  // warnings and errors (vblALLBAD). Remove 'vblALLMESS' to get rid of 
  // many information messages during execurion.
  // The program is interrupted on errors (vblERR).
  message_logger::global().set_levels(vblALLBAD | vblALLMESS, vblERR);
  
  // All distributed code should be put into gridmd_main() function
  int res= gridmd_main(argc, argv);

  gmdUninitialize();
  return res;
}


// Note that this function may be called recursively.
// Use global variables with care!
int gridmd_main(int argc,char* argv[]){

  // GridMD initialization and processing of the command line arguments
  gmExperiment.init(argc,argv);

  // When uncommented, the data for the data links will be transfered
  // through the files created in the current directory, otherwise
  // the data is passed through the memory.
  gmExperiment.set_link_files(gmFILES_LOCAL | gmFILES_CLEANUP);

  // Set the execution mode
  //gmExperiment.set_execution(gmEXE_SERIAL);  // Serial execution where the GridMD calls are ignored
  //gmExperiment.set_execution(gmEXE_CONSTRUCT_ONLY);  // Construction of the execution graph
  gmExperiment.set_execution(gmEXE_REMOTE);  // Construction of the execution graph and/or
                                            // execution of the selected (all) nodes on the local host
  //gmExperiment.set_execution(gmEXE_REMOTE); // Construction and execution on the remote system(s).
  //                                          // Please set up resources as explained below.
  // Information about external applications, available resource managers and
  // accounts on the remote systems can be stored to XML file (see template in
  // resources.xml). YOU MUST EDIT THIS FILE and specify the appropriate data
  // in order to use 'gmEXE_REMOTE' execution type. Alternatively you can create
  // an instance of gmResourceDescr, fill in the corresponding fields and pass it
  // to the gmExperiment.add_resource() function.
  gmExperiment.load_resources("pbs_libssh.xml");

  // Remove '& (~gmGV_NODESTATE)' to get additional information about node states
  // on the graph generated by graphviz
  gmExperiment.set_graphviz_flags(gmGV_ALL & (~gmGV_NODESTATE));

  // Data types for the data transfer
  typedef double arg_t;   // argument type
  typedef double value_t; // result type
  value_t (*A)(arg_t) = sin, (*B)(arg_t) = cos;  // test functions
  arg_t x = 0.3;          // test argument
  value_t result;

  begin_distributed();  // creates 'start' node on the execution graph
  
  // Node 'A' is automatically linked to the previous 'start' node using the hard link
  if( node("A") ) // node construction
    node_output<value_t>() = A(x); // calculation of node output: A(X)
  
  // Node 'B' is exlicitly linked to 'start' using the hard link
  if( node("B", get_curnode()-1) )
    node_output<value_t>() = B(x); // calculation of B(X)
  
  // Node with value_t data links from A and B
  if( node("C=A*B", "(A|B)", gmDataLink<value_t>()) )
    node_output<value_t>(0) = node_input<value_t>(0) * node_input<value_t>(1); 
  
  // Node 'D=A+B' has the same inputs as 'C=A*B'
  if( node("D=A+B", "(A|B)", gmDataLink<value_t>(),0) )
    node_output<value_t>() = node_input<value_t>(0) + node_input<value_t>(1); 
  
  // Node 'E=C/D' has value_t data links from 'C=A*B' and 'D=A+B')
  if( node("E=C/D", "(C.*|D.*)", gmDataLink<value_t>()) )
    node_output<value_t>()=node_input<value_t>(0) / node_input<value_t>(1); 
  
  // This node is linked to all previous nodes with no outputs (actually 'E=C/D').
  if( node("get_result", gmNODE_NOOUTPUTS, gmDataLink<value_t>()) )
    result = node_input<value_t>(); 
 
  if( end_distributed() )  // adds 'finish' node
    printf("=== The result is %g\n", result);

  return 0;
}
