/****************************************************************************
 *
 *   Copyright (c), Ilya Valuev, Igor Morozov 2005-2010        All Rights Reserved.
 *
 *   Author	: Ilya Valuev, Igor Morozov, JIHT RAS, Moscow, Russia
 *
 *   Project	: GridMD
 *
 *   This source code is Free Software and distributed under the terms of GridMD license
 *   (gridmd\doc\gridmd_license.txt)
 *
 *   The example "fork_skeleton_extra" performs calculation of first N terms of the series
 *                    x^2   x^3         x^N
 *   exp(x) = 1 + x + --- + --- + ... + --- + ...
 *                     2     6           N!
 *   Each term is calculated as a separate job. First N terms and subsequent N_extra terms
 *   of the series are calculated using two gmFork template and split-merge skeletons.
 *   Example shows how to merge the results of multiple distributed loops.
 *
 *****************************************************************************/

#include "gridmd.h"
#include "gmfork.h"
#include <cmath>

using namespace gridmd;


int main(int argc,char* argv[]){

  // wxWindows initialization
  if( !gmdInitialize() ) {
    puts("Failed to initialize the GridMD library.");
    return -1;
  }

  // The following command enables output of information messages (vblALLMESS),
  // warnings and errors (vblALLBAD). Remove 'vblALLMESS' to get rid of 
  // many information messages during execurion.
  // The program is interrupted on errors (vblERR).
  message_logger::global().set_levels(vblALLBAD | vblALLMESS, vblERR);
  

   // When uncommented, the data for the data links will be transfered
  // through the files created in the current directory, otherwise
  // the data is passed through the memory.
  gmExperiment.set_link_files(gmFILES_LOCAL | gmFILES_CLEANUP);

  // Set the execution mode
  //gmExperiment.set_execution(gmEXE_SERIAL);  // Serial execution where the GridMD calls are ignored
  //gmExperiment.set_execution(gmEXE_CONSTRUCT_ONLY);  // Construction of the execution graph
  gmExperiment.set_execution(gmEXE_LOCAL);  // Construction of the execution graph and/or
                                            // execution of the selected (all) nodes on the local host
  //gmExperiment.set_execution(gmEXE_REMOTE); // Construction and execution on the remote system(s).
  //                                          // Please set up resources as explained below.
  // Information about external applications, available resource managers and
  // accounts on the remote systems can be stored to XML file (see template in
  // resources.xml). YOU MUST EDIT THIS FILE and specify the appropriate data
  // in order to use 'gmEXE_REMOTE' execution type. Alternatively you can create
  // an instance of gmResourceDescr, fill in the corresponding fields and pass it
  // to the gmExperiment.add_resource() function.
  gmExperiment.load_resources("../resources.xml");

  // Remove '& (~gmGV_NODESTATE)' to get additional information about node states
  // on the graph generated by graphviz
  gmExperiment.set_graphviz_flags(gmGV_ALL & (~gmGV_NODESTATE));

  // All distributed code should be put into gridmd_main() function
  int res= gridmd_main(argc, argv);

  gmdUninitialize();
  return res;
}


// Note that this function may be called recursively.
// Use global variables with care!
int gridmd_main(int argc,char* argv[]){

  // GridMD initialization and processing of the command line arguments
  gmExperiment.init(argc,argv);

 
  // Data types for the data transfer
  typedef double arg_t;   // argument type
  typedef double value_t; // result type
  arg_t x = 1.0;          // argument value for exp(x)
  int nterms = 4, nterms_extra = 2; // number of terms in the first and second loops
  int i, fact = 1;
  value_t sum = 0;

  begin_distributed();  // creates 'start' node on the execution graph
  gmFork<void,int,void> fork1("loop");  // defines the first skeleton
  gmFork<void,value_t> fork2("extra");  // defines the second skeleton

  fork1.begin();
  fork2.begin_here();  // 'begin' nodes of both loops coincide

  // First loop
  for(i = 0; i < nterms; i++){
    fact = i>0 ? fact*i : fact;  // fact is the factorial (denominator for the current term)
    // Create a new 'split' node which returs the value of factorial
    if(fork1.split())
      fork1.vsplit_out() = fact;
    // Add an intermadiate unnamed node which calculates the series term
    if(node("",gmNODE_PREV,gmDataLink<value_t>()))
      node_output<value_t>() = pow(x,(value_t)i) / node_input<int>();
    // Define the action of the 'merge' node and link it to the pervious unnamed node
    if(fork1.merge("",gmNODE_PREV,gmDataLink<value_t>()))
      sum += node_input<value_t>();  // accumulation of the terms
  }

  // Second loop
  for(i = nterms; i < nterms + nterms_extra; i++){
    fact = i>0 ? fact*i : fact;
    // Create a new 'split' node which calculates the series term
    if(fork2.split())
      // two output ports for connections with 'loop.end' and 'extra.end' nodes
      fork2.vmerge_out(0) = fork2.vmerge_out(1) = pow(x,(value_t)i)/fact;
  }
  
  int fork1_end = fork1.end();
  fork2.end_here();  // You should call fork1.end before fork2.end_here!

  // Modify the 'loop.end' node: add the results of the second loop
  if( fork1_end ){
    for(size_t j=0; j<fork2.branchcount(); j++)
      sum += fork2.vend_in(j);
    printf("=== First %d terms of exp(%g) series result in %g\n",
           nterms + nterms_extra, x, sum);
  }
  
  // User 'extra.end' node for output of the result of extra terms
  if( fork2.end() ){
    value_t subsum = 0.;
    for(size_t j=0; j<fork2.branchcount(); j++)
      subsum += fork2.vend_in(j);
    printf("=== Extra terms sum is %g\n", subsum);
  }

  end_distributed();  // adds 'finish' node

  return 0;
}
