/****************************************************************************
 *
 *   Copyright (c), Ilya Valuev, Igor Morozov 2005-2010        All Rights Reserved.
 *
 *   Author	: Ilya Valuev, Igor Morozov, JIHT RAS, Moscow, Russia
 *
 *   Project	: GridMD
 *
 *   This source code is Free Software and distributed under the terms of GridMD license
 *   (gridmd\doc\gridmd_license.txt)
 *
 *   The example "simple_workflow_fork" is analogous to "simple_workflow" but
 *   uses gmFork template instead of the explicit node creation/link functions.
 *
 *****************************************************************************/

#include "gridmd.h"
#include "gmfork.h"
#include <cmath>

using namespace gridmd;


int main(int argc,char* argv[]){

  // wxWindows initialization
  if( !gmdInitialize() ) {
    puts("Failed to initialize the GridMD library.");
    return -1;
  }

  // The following command enables output of information messages (vblALLMESS),
  // warnings and errors (vblALLBAD). Remove 'vblALLMESS' to get rid of 
  // many information messages during execurion.
  // The program is interrupted on errors (vblERR).
  message_logger::global().set_levels(vblALLBAD | vblALLMESS, vblERR);
  
  // All distributed code should be put into gridmd_main() function
  int res= gridmd_main(argc, argv);

  gmdUninitialize();
  return res;
}


// Note that this function may be called recursively.
// Use global variables with care!
int gridmd_main(int argc,char* argv[]){

  // GridMD initialization and processing of the command line arguments
  gmExperiment.init(argc,argv);

  // When uncommented, the data for the data links will be transfered
  // through the files created in the current directory, otherwise
  // the data is passed through the memory.
  gmExperiment.set_link_files(gmFILES_LOCAL | gmFILES_CLEANUP);

  // Set the execution mode
  //gmExperiment.set_execution(gmEXE_SERIAL);  // Serial execution where the GridMD calls are ignored
  //gmExperiment.set_execution(gmEXE_CONSTRUCT_ONLY);  // Construction of the execution graph
  gmExperiment.set_execution(gmEXE_LOCAL);  // Construction of the execution graph and/or
                                            // execution of the selected (all) nodes on the local host
  //gmExperiment.set_execution(gmEXE_REMOTE); // Construction and execution on the remote system(s).
  //                                          // Please set up resources as explained below.
  // Information about external applications, available resource managers and
  // accounts on the remote systems can be stored to XML file (see template in
  // resources.xml). YOU MUST EDIT THIS FILE and specify the appropriate data
  // in order to use 'gmEXE_REMOTE' execution type. Alternatively you can create
  // an instance of gmResourceDescr, fill in the corresponding fields and pass it
  // to the gmExperiment.add_resource() function.
  gmExperiment.load_resources("../resources.xml");

  // Remove '& (~gmGV_NODESTATE)' to get additional information about node states
  // on the graph generated by graphviz
  gmExperiment.set_graphviz_flags(gmGV_ALL & (~gmGV_NODESTATE));

  // Data types for the data transfer
  typedef double arg_t;   // argument type
  typedef double value_t; // result type
  value_t (*A)(arg_t) = sin, (*B)(arg_t) = cos;  // test functions
  arg_t x = 0.3;          // test argument
  value_t result;

  begin_distributed();  // creates 'start' node on the execution graph
  gmFork<void,value_t> fork0; // defines the gmFork instance

  if( fork0.split("A") )
    fork0.vsplit_out() = A(x); // calculation of A(X), same as node_output<value_t>()=A(x);

  if( fork0.split("B") )
    fork0.vsplit_out() = B(x); // calculation of B(X)

  if( fork0.end("C=A*B") ) // same as =node_input<value_t>(0)*node_input<value_t>(1); 
    node_output<value_t>(0) = fork0.vend_in(0) * fork0.vend_in(1);
  
  if( fork0.end("D=A+B",true) )
    node_output<value_t>(0) = fork0.vend_in(0) + fork0.vend_in(1);
  
  // Node 'E' is linked to all previous nodes with no outputs (actually C, D).
  // The link type is 'data' with value_t data type.
  if( node("E=C/D", gmNODE_NOOUTPUTS, gmDataLink<value_t>()) )
    node_output<value_t>() = node_input<value_t>(0) / node_input<value_t>(1); 

  if( node("get_result", gmNODE_PREV, gmDataLink<value_t>()) )
    result = node_input<value_t>();

  if( end_distributed() )  // adds 'finish' node
    printf("=== The result is %g\n", result);

  return 0;
}
